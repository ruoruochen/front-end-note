## 一、操作系统引论

1、操作系统的目标：有效性、方便性、可扩充性、开放性。

2、操作系统的作用：为用户和计算机系统之间提供接口、管理计算机系统资源、对计算机资源

3、操作系统的发展：人工操作、脱机输入输出、单道批处理系统、**多道批处理系统**（真正的操作系统）、分时系统、实时系统。

- 单道批处理系统特点
  - 自动性：作业自动逐个运行。
  - 顺序性：顺序进入内存，顺序完成操作。
  - 单道性：内存只有一道程序运行。

- 多道批处理系统

  用户提交的作业在外存排队，构成后备队列；之后，由作业调度程序从后备队列中选择若干作业调入内存，共享 CPU 和系统资源。

  - 多道批处理系统优缺点：
    - 优点：资源利用率高、系统吞吐量大（单位时间内完成的总工作量）
    - 缺点：平均周转时间长（从作业进入系统，到完成并退出系统为止的时间）、无交互能力

- 分时系统

  一台主机连接了若干个终端，每个终端有一个用户在使用，向系统提出命令请求，系统接受每个用户的命令，采用**时间片轮转**方式处理服务请求，通过交互方式在终端上向用户显示结果。

  - 分时系统的特点
    - 多路性：一个主机连接多台终端，按分时原则为多个用户服务。
    - 独立性：一个用户一个终端，操作独立
    - 及时性：时可以在很短时间内获得响应。
    - **交互性**：人机对话。

- **实时系统与批处理系统和分时系统的区别**

  - 专用系统：许多实时系统是专用系统，而批处理与分时系统通常是通用系统
  - 实时控制：实时系统用于控制实时过程，要求对外部事件的迅速响应，具有较强的中断处理机构
  - 高可靠性：实时系统用于控制重要过程，要求高度可靠
  - 事件驱动和队列驱动：实时系统的工作方式：接受外部消息，分析消息，调用相应处理程序进行处理。

4、操作系统的基本特性：并发性、共享性（互斥共享、同时访问）、虚拟性（时分复用、空分复用）、异步性。

>并发性指的是多个事件在**同一时间间隔**内发生。并行性是多个事件在同一时刻发生。

5、操作系统的主要功能：处理机管理、存储器管理、设备管理功能、文件管理功能、操作系统与用户之间的接口。

- 处理机管理
  1. 进程控制：创建进程、撤销结束进程、控制进程状态转换。
  2. 进程同步，为多个进程运行进行协调，协调方式有：
     - 进程互斥方式：对临界资源访问时，采用互斥。
     - 进程同步方式：完成共同任务的进程（线程）间，由同步机构对执行次序协调。
  3. 进程通信：实现相互合作的进程之间的信息交换
  4. 调度：作业需要经过调度才能执行，分为作业调度和进程调度
     - 作业调度：从后备队列选择若干作业，分配运行所需资源（首先分配内存）、建立进程，使之成为就绪进程，按一定规则插入就绪队列。
     - 进程调度：即分配CPU。从就绪队列中，按照一定的算法选出一个进行，为其分配CPU。

- 存储器管理

  - 内存分配：为每道程序分配内存空间，应具备以下结构和功能

    - 内存分配数据结构，记录内存空间使用情况
    - 内存分配功能
    - 内存回收功能

  - 内存保护：保证每道用户程序互不干扰

  - 地址映射：将**地址空间**的**逻辑地址**转换为**内存空间**的**物理地址**

    >一个应用程序经编译后，通常会形成若干个目标程序； 这些目标程序再经过链接便形成了可装入程序。这些程序的地址所形成的地址范围称为“地址空间” ，其中的地址称为“逻辑地址” 或“相对地址” 。此外，由内存中的一系列单元所限定的地址范围称为“内存空间” ，其中的地址称为“物理地址” 。

  - 内存扩充：借助虚拟存储技术，从逻辑上扩充内存。

    - 请求调入功能。允许在装入一部分用户程序和数据的情况下，便能启动该程序运行。运行过程中，所需程序数据未装入内存，可向OS发出请求，OS将所需部分调入内存。
    - 置换功能。若发现在内存中已无足够的空间来装入需要调入的程序和数据时，系统应能将内存中的一部分暂时不用的程序和数据调至盘上，以腾出内存空间，然后再将所需调入的部分装入内 存。

- 设备管理功能

  完成用户进程提出的I/O请求，分配设备、完成操作；提高CPU和I/O设备的利用率。

  为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。

  1. 缓冲管理：设置缓冲区，缓和CPU和I/O设备速度不匹配的矛盾，提高CPU利用率，提高系统吞吐量。
  2. 设备分配：根据用户进程的I/O请求、资源状况、设备分配策略等，分配所需设备。
  3. 设备处理：实现CPU和设备控制器之间的通信。

- 文件管理功能
  1. 文件存储空间管理：为每个文件分配外存空间。
  2. 目录管理：为每个文件建立目录项
  3. 文件的读写管理和保护

- 操作系统与用户之间的接口
  1. 用户接口
  2. 程序接口

## 二、进程管理

1、程序顺序执行时的特征

- 顺序性：每一操作必须在上一个操作完成后开始

- 封闭性：程序运行独占全部资源，不受外界影响

- 可再现性：只要程序执行环境和初始条件相同，当程序重复执行时，结果相同

2、程序并发执行的特征

- 间断性：并发执行的程序由于共享资源，以及为了完成同一任务相互合作，相互制约。将导致并发程序具有“执行-暂停-执行”间断性活动规律。

- 失去封闭性：多个程序共享资源。

- 不可再现性：由于失去封闭性，也就失去了再现性。即使执行环境和初始条件相同，结果却各不相同。

3． 进程的特征：

- 结构特征：进程实体由**程序段**、**相关的数据段**和**进程控制块（PCB）**三部分组成。

- 动态性：进程的实质是进程实体的一次执行过程。

- 并发性：多个进程实体同时存在于内存中，在能同一时间段内同时运行。

- 独立性：进程实体是可以独立运行/独立分配资源和独立接受调度的基本单位。而未建立 PCB 的程序不能作为一个单独的单位参与运行。

- 异步性：指进程按各自独立的，不可预知的速度向前推进。

4、进程的定义：进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。

5、进程的三个基本状态：

- 就绪状态：进程已分配到除了 CPU 之外的所有必要资源，只要再获得 CPU，便可立即执行。

- 执行状态：进程已获得 CPU，程序正在运行。
- 阻塞状态：进程的暂停状态称为阻塞状态。致使进程阻塞的典型事件有：请 求I/O，申请缓冲空间等。

![image-20210511163625003](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511163625003.png)

6、进程的挂起状态

1. 引入挂起状态的原因有：终端用户请求、父进程请求、负荷调节的需求、操作系统需求。<br>**挂起的原因，都是外部的，不是程序本身的原因**

2. 进程状态的转换

   在引入挂起状态后，又将增加挂起状态(静止状态)和非挂起状态(活动状态)之间的相互转换。

   - 活动就绪 → 静止就绪。没挂起前，活动就绪；挂起后，静止就绪。处于静止就绪的进程不再被调度执行。
   - 活动阻塞 → 静止阻塞。处于静止阻塞的进程在所期待的事件出现后，将从静止阻塞转为静止就绪。
   - 静止就绪 → 活动就绪。静止就绪**激活**后变为活动就绪，此时可以被调度执行。
   - 静止阻塞 → 活动阻塞。静止阻塞**激活**后变为活动阻塞

![image-20210511165756275](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511165756275.png)

7、创建状态和结束状态（了解即可）

![image-20210511170128701](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511170128701.png)

![image-20210511170210310](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511170210310.png)

创建状态：首先创建一个 PCB，将该进程转入就绪状态并插入就绪队列。

进程状态：首先等待操作系统进行善后处理，然后清空 PCB，并将 PCB 空间返还系统。

5． 进程控制块 PCB

- 进程控制块的作用

  PCB 记录了操作系统所需的、用于描述进程当前情况以及控制进程运行的全部信息。使得一个在多道程序环境下不能独立运行的程序(含数据)，成为一个能独立运行的基本单位。**PCB是进程存在的惟一标志。**

- 进程控制块PCB中的信息

  1. 进程标识符：用于唯一的标识一个进程，一个进程通常由两种标识符：
     - 内部标识符：进程序号，为方便系统使用。
     - 外部标识符：创建者提供，由用户（进程）在访问该进程时使用。
  2. 处理机状态：由各种寄存器中的内容组成。
     - 通用寄存器：暂存信息
     - 指令计数器：下一条指令地址
     - 程序状态字PSW：状态信息，如条件码、执行方式
     - 用户栈指针：存放过程和调用参数、地址。
  3. 进程调度信息：进程状态、进程优先级、进程调度所需的其他信息、事件（阻塞原因）。
  4. 进程控制信息
     - 程序和数据的地址
     - 进程同步和通信机制
     - 资源清单，除CPU外所需资源及已分配的清单。
  5. PCB组织信息：下一个进程PCB的首地址。

- 进程控制块的组织方式

  1. 链式方式：把同一状态的 PCB，用链接字链接成一个队列，形成就绪队列、若干个阻塞队列和空白队列。

     ![image-20210511181815940](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511181815940.png)

  2. 索引方式：根据进程状态建立几张索引表，如就绪索引表、阻塞索引表等，并把各个索引表在内存的首地址记录在内存的一些专用单元中。在每个索引表的表目中，记录有相应状态的某个 PCB 在PCB 表中的地址。

  ![image-20210511182114065](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511182114065.png)

6、进程控制

进程控制一般是由OS的内核中的原语来实现的。

原语：由若干条指令组成的，用于完成一定功能的一个过程，是原子操作，指一个操作中的所有动作要么全做，要么全不做，即执行过程不可终端。原子操作在管态下执行，常驻内存。

- 进程图/树：用于描述一个进程的家族关系的有向树。

![image-20210511183610610](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210511183610610.png)

- 进程创建

  - 引起创建进程的事件有：用户登录、作业调度、提供服务、应用请求。

  >多道程序环境中，只有进程才能在系统运行。为使程序能运行，就必须为它创建进程。

  - 进程创建的过程

  1. 申请空白PCB
  2. 为新进程分配资源
  3. 初始化PCB。包括标识信息、处理机状态信息、处理机控制信息等。
  4. 将新进程插入就绪队列。

- 进程终止
  - 引起进程终止的事件：
    - 正常结束，进程完成。
    - 异常结束：越界错误、保护错、非法指令、运行超时
    - 外界干预：操作员干预、父进程请求（父进程有权终止子孙进程）、父进程终止（父终子终）
  - 进程终止的过程
    1. 根据被终止进程的标识符，从PCB集合中检索出该进程的 PCB，从中读出该进程的状态。
    2. 若被终止进程正处于执行状态，应立即终止该进程的执行， 并置调度标志为真，用于指示该进程被终止后应重新进行调度。
    3. 若该进程还有子进程，终止子进程。
    4. 将被终止进程所拥有的全部资源，或者归还给其父进程，或者归还给系统。
    5. 将被终止进程的PCB从队列/链表中移出。
- 进程阻塞与唤醒
  - 引发阻塞和唤醒的事件
    - 请求系统服务
    - 启动某种操作，需等待该操作完成后才能继续执行。例如启动了I/O操作。
    - 新数据尚未到达，合作进程需要等待另一个进程提供数据。
    - 无新工作可做。存在特定功能的系统进程，完成任务后，阻塞等待新任务。例如系统的发送进程。
  - 进程阻塞的过程：当正在执行的进程，发现以上阻塞时间无法继续执行，则调用block原语把自己阻塞。**进程的阻塞是进程自身的一种主动行为**。进入block过程后，由于此时该进程还处于执行状态， 所以应先立即停止执行，把进程控制块中的现行状态由“执行”改为 “阻塞” ，并将PCB插入阻塞队列。
  - 进程唤醒的过程：首先把被阻塞的进程从等待该事件的阻塞队列中移出，将其PCB中的现行状态由 阻塞改为就绪，然后再将该PCB插入到就绪队列中。

- 进程的挂起与激活
  - 进程挂起的过程：首先检查被挂起进程的状态，若处于活动就绪状态，便将其改为静止就绪； 对于活动阻塞状态的进程，则将之改为静止阻塞。
  - 进程激活的过程：先将进程从外存调入内存，检查该进程的现行状态，若是静止就绪，便将之改为活动就绪；若为静止阻塞，便将之改为活动阻塞。

7、进程同步

- 两种形式的制约关系

  由于资源共享和进程合作，进程间存在两种形式的制约关系：

  - 间接相互制约关系：资源共享。
  - 直接相互制约关系：进程合作。

- 临界资源

  对于临界资源，如打印机、磁带机等，进程间采取互斥方式，实现资源共享。

  **临界资源实现进程同步的例子：生产者-消费者问题**

- 临界区

  进程中访问临界资源的那段代码称为临界区。在临界区前面增加一段用于检查的代码，叫做为进入区。相应地，在临界区后面也要加上一段称为退出区，用于将临界区正被访问的标志恢复为未被访问的标志。余下区域为剩余区。

  - 同步机制应遵循的规则
    1. 空闲让进
    2. 忙则等待
    3. 有限等待，要求访问临界资源的进程，应保证在有限时间内能进入临界区，避免陷入“死等”状态。
    4. 让权等待，如进程不能进入临界区，立即释放处理结果，以免陷入“忙等”状态。

- 信号量机制

  1. 整型信号量

  整型信号量的定义：一个用于表示资源数目的整型量S，除初始化外，仅能通过两个标准的原子操作wait(S)和signal(S)来访问，即P、V操作。原子操作在执行时是不可中断的。

  ```c++
  void wait(int s){
      while(s<=0)//当没有资源可以利用时，等待
      	;
      s=s-1;//当有资源时，使用。每使用一个，资源个数减一
  }
  void signal(int s){
  	s=s+1;//释放资源，资源个数加一
  }
  ```

  2. 记录型信号量
  3. AND型信号量

  ​		有时候一个进程需要先获得两个或更多的共享资源后方能执行其任务，则这些共享资源都作为临界资源。AND同步机制的基本思想是：将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。 只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源也不分配给它。这样子就可以避免死锁。此时，需要在信号量中增加了一个“AND”条件，称同步wait操作，Swait。	

  ```C++
  Swait(S1，S2，…，Sn){
      while (TRUE){
          if (Si>=1 &&..&& Sn>=1){
              for(i =1; i<=n; i++) Si--;
              break;
          }
  		else{
         		 place the process in the waiting queue associated with the first Si found with Si<1,and set the program count of this process to the beginning of Swait operation
          }	
      }
  }
          
  Ssignal(S1，S2，…，Sn){
      while (TRUE){
          for(i=1; i<=n; i++){
              Si++;
              Remove all the process waiting in the queue associated with Si into the ready queue.
          }
      }
  }
  ```

- 信号量的应用

  1. 利用信号量实现进程互斥（竞争）

     ​		为使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥 信号量mutex，并设其**初始值为1**，然后将各进程访问该资源的临界区置于wait(mutex)和signal(mutex)操作之间即可。

     ​		这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex执行wait操作，若该资源此刻未被访问，本次wait操作必然成功，进程便可进入自己的临界区，这时若再有其他进程也欲进入自己的临界区，此时由于对mutex执行wait操作定会失败，因而该进程阻塞，从而保证了该临界资源能被互斥地访问。 当访问临界资源的进程退出临界区后，又应对mutex执行signal操作，以便释放该临界资源。

  2. 利用信号量实现前趋关系 （协作）

     ​		利用信号量来描述程序或语句之间的前趋关系。设有两个并发执行的进程P1和P2。P1中有语句S1；P2中有语句S2。我们希望在S1执行后再执行S2。为实现这种前趋关系，我们只须使进程P1和P2共享一个公用信号量S，并赋予其初值为0，将signal(S)操作放在语句S1后面；而在S2 语句前面插入wait(S)操作。

     ​		由于S被初始化为0，这样，若P2先执行必定阻塞，只有在进程P1执 行完S1；signal(S)；操作后使S增为1时，P2进程方能执行语句S2成功。**例子：**

     图示出了一个前趋图，其中S1，S2，S3，…，S6是最简单的程序段(只有一条语句)。为使各程序段能正确执行，应设置若干个初始值 为“0”的信号量。如为保证S1→S2，S1→S3的前趋关系，应分别设置 信号量a 和b，同样，为了保证S2→S4，S2→S5，S3→S6，S4→S6和 S5→S6，应设置信号量c，d，e，f，g。

  ​        ![image-20210512092900375](C:%5CUsers%5CAsus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210512092900375.png)

  ​			**代码框架描述：**

  ```c++
  p1(){S1;signal(a);signal(b);}
  p2(){wait(a);S2;signal(c);signal(d);}
  p3(){wait(b);S3;signal(e);}
  p4(){wait(c);S4;signal(f);}
  p5(){wait(d);S5;signal(g);}
  p6(){wait(f);wait(g);wait(e);S6;}
  main(){
      semaphore a,b,c,d,e,f,g;
      a.value = b.value = c.value = d.value = e.value = f.value = g.value = 0;
      cobegin
          p1();p2();p3();p4();p5();p6();
  	coend 
  }
  ```

#### 8、经典进程的同步问题

##### 生产者-消费者问题

假定在生产者和消费者之间的公用缓冲池中具有n 个缓冲区，这时可利用互斥信号量mutex 实现诸进程对缓冲池的互斥使用；利用信号量 empty 和 full 分别表示缓冲池中空缓冲区和满缓冲区的数量。又假定这些生产者和消费者相互等效，只要缓冲池未满，生产者便可将消息送入缓冲池；只要缓冲池未空，消费者便可从缓冲池中取走一个消息。

信号量有：互斥信号量 `mutex` ，(资源信号量)空缓存区数量`empty`，(资源信号量)使用缓存区数量`full`，分别初始化为1，n，0。

其他变量：in、out代表第一个资源和最后一个资源；buf[n] 代表缓冲区，类型为Item。

注意事项：

mutex 的作用：多个进程的互斥

empty 的作用：是否有缓冲区影响了生产者是否生产。

full 的作用：是否有产品影响了消费者是否能取

**应先执行对资源信号量的 wait 操作，然后再执行对互斥信号量的 wait 操作，否则可能引起进程死锁。**

![image-20210512210137576](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210512210137576.png)

```c++
int in = 0, out = 0;
item buffer[n];
semaphore metux = 1,empty = n,full = 0;
producer(){
    while( true ) {
        wait(empty);  // 等待空缓存区
        wait(metux);  // 等待互斥锁

        buffer[in] = nextp  // 将新资源放到buffer[in]位置 
        in = ( in + 1 ) % 10;
        empty -- ;
        signal(mutex);  // 释放互斥锁
        signal(full);  // 增加使用缓存区
    }
}

consumer() {
    while( true ) {
        wait(full);  // 等待使用缓存区
        wait(mutex); // 等待互斥锁

        // consumer
       	nextc = buffer[out]// 将buf[out]位置的的资源取走
        out = ( out + 1 ) % 10;
		ful--
        signal(mutex);  // 释放互斥锁
        signal(empty);  // 增加空缓存区
    }
}

void main(){
    cobegin
        producer();producer();
   	coend
}
```

##### 哲学家进餐问题

有五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。

1、利用记录型信号量解决

五根筷子，五个信号量；所有信号量均初始化为1 ，第i为哲学家的活动：

```c++
semaphore chopstick[5] = [1,1,1,1,1];

while(true){
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    
    eat;
    
    signal(chopstick[i]);
    signal(chopstick[(i+1)%5]);
    
    think;
}
```

可能引起死锁，如五位同时饥饿而拿起左边筷子，所有信号量为0，进入无限等待。

**解决死锁的解决方案**

1、至多只允许有四位哲学家同时去拿左边的筷子，最终能保证至 少有一位哲学家能够进餐，并在用毕时能释放出他用过的两只筷子， 从而使更多的哲学家能够进餐。

2、仅当哲学家的左、右两只筷子均可用时，才允许他拿起筷子进 餐。即and信号量。

**限制4位**

增加信号量N：允许同时进餐人数，初始值为4。

第i个哲学家的过程：

```c
while(true){
    wait(N);
    wait(chopstick[i]);
    wait(chopstick[(i+1)%5]);
    eat;
    signal(chopstick[i]);
    signal(chopstick[(i+1)%5]);
    signal(N);
    think;
}
```

**AND信号量**

第i个哲学家的过程：

```js
semaphore chopstick[5] = [1,1,1,1,1];
while(true){
    Swait(chopstick[i],chopstick[(i+1)%5]);//同时拿起左右筷子
    eat;
    Ssignal(chopstick[i],chopstick[(i+1)%5]);//同时放下
    think;
}
```

##### 读者-写者问题

保证一个 Writer 进程必须与其他进程互斥地访问共享对象的同步问题。

1、利用记录型信号量解决

信号量：写互斥信号量wmutex，读互斥信号量emutex(readcount是一个可被多个Reader进程访问的临界资源)

其他变量：读进程数：readcount、

```c
semaphore rmutex = 1,wmutex = 1; //读写之间互相制约
int readcount =0;
reader(){
    while(true){
        //开始读
        wait(rmutex)//等待读
        if(readcount == 0) wait(wmutex);//等待写
        readcount ++;//数量+
        signal(rmutex);//释放读
        
        ...read 读
        //读完之后
        wait(rmutex);//等待读
        readcount--;//数量-
        if(readcount == 0) signal(wmutex);//等待写
        signal(rmutex);//释放
    }
}

writer(){
    while(true){
        wait(wmutex);//等待写
        writer...//写
        signal(wmutex);//释放写
    }
}

void main(){
    cobegin
        reader();writer();
    coend
}
```

##### 理发师问题

角色有两个，理发师和顾客 只有一个理发师和一把理发椅子，另有N把椅子供顾客休息等待。没有顾客时，理发师休息，等待顾客 每个顾客来时，先看是否有椅子空位，有空位，坐下等待；否则不等待直接走。

信号量：理发师资源信号量barber，顾客资源信号量customers，互斥信号量mutex实现进程互斥，分别初始化为0,0,1（没有顾客时，理发师休息、刚开始顾客没来、进程互斥）

其他变量：顾客数量 count ，初始化为0

注意事项：理发师是一个循环，顾客多个，但每个只执行一次。

首先，空闲椅子的有无影响了等待顾客的数量，而顾客的有无影响了理发师是否开始理发，所以要使用不同的信号量来处理。customers这个信号量的作用，和生产者消费者里面的full的作用差不多。

```c++
semaphore barber = 0,customers = 0 ,mutex = 1;
int count = 0;

barber(){
	while(true){
		wait(customers);//barber等待顾客叫他
        wait(mutex);//等待互斥锁，只能被一个顾客叫醒
        count --;//等待区椅子空1
        cut_hair() //剪头发
        signal(barber);//剪发后 理发师资源被释放
        signal(mutex);//释放互斥锁
	}
}

customers(){
    wait(mutex);//等待互斥锁被释放
    if(count<n){ //人少，进入椅子等待
        count ++;
        signal(customers);//通知顾客资源信号量
		signal(mutex);//访问椅子结束
        wait(barber);//等待理发师
        get_haircut();//得到服务
    }else{
        signal(mutex);//走了，释放互斥锁
    }
}

void main(){
    cobegin
        barber();customers();customers();
    coend
}
```

