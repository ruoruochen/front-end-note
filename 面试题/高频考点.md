### 1.地址栏中输入网址后发生了什么

```
1.URL解析
2.缓存查找
3.DNS解析
4.TCP连接，三次握手
5.http请求
6.服务器响应，浏览器解析。
7.浏览器渲染
8.TCP连接断开，4次挥手
```

从用户输入一个网址到网页最终展现，中间的大致流程如下：

（1）首先浏览器会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果URL的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会进行缓存查找。判断请求资源是否在缓存里，如果请在并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）进行DNS解析，获取URL中域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有**本地 DNS 服务器**向**根域名服务器**发起请求，获得负责的顶级域名服务器的地址后，再向**顶级域名服务器**请求，然后获得负责的权威域名服务器的地址后，再向**权威域名服务器**发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地DNS服务器发起请求属于递归请求（本地服务器会帮主机进行DNS查询，这一步对主机是透明的。因此是属于递归），本地DNS服务器向各级域名服务器发起请求属于迭代请求。（迭代的查询IP）

![img](https://img-blog.csdnimg.cn/img_convert/4cf5cf49f70dad69bbfde1f1311af582.png)

（4）我们通过DNS解析获取到IP地址后， 需要发起TCP连接请求。 TCP 建立连接需要经历三次握手的过程，首先客户端向服务器发送一个 **SYN 连接请求报文段**和一个随机序号，服务端接收到请求后向客户端发送一个 **SYN ACK报文段**和一个随机序号，确认连接请求。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 **ACK 确认报文段**，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

```
在TCP报文的报头中，有几个标志字段：
1、 SYN：同步连接序号，TCP SYN报文就是把这个标志设置为1，来请求建立连接；
2、 ACK：请求/应答状态。0为请求，1为应答；
3、 FIN：结束连线。如果FIN为0是结束连线请求，FIN为1表示结束连线；
```



![三次握手.png](https://img-blog.csdnimg.cn/img_convert/75dc3da5603f7f2e528b057a52563948.png)

（5）握手成功后， 浏览器就可以向服务器发送**http**请求了。 **发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)**。HTTP请求报文是由三部分组成: 请求行,请求报头和请求正文。

（6）在服务端会监听浏览器端发送的http请求，当浏览器的请求发出后，服务端就会接受该请求，并对相应的信息进行处理，将处理的结果响应给浏览器端。浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（7）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局，计算每个节点的几何位置。布局完成后，进入绘制阶段，将各个节点绘制到屏幕上。这个时候整个页面就显示出来了。

（8）最后一步是 断开 TCP连接，需要经历四次挥手过程。

4次挥手大体的过程如下：

1. 客户端向服务器发送一个**FIN连接释放报文段**和一个随机序号，通知服务器现在需要断开（第一次挥手）
2. 服务器接到要断开的请求之后，向客户端发送一个**ACK确认报文段**和一个随机序号，服务端进入CLOSE_WAIT（关闭等待）状态（第二次挥手）
3. 如果服务端也想断开连接了，向客户端发送一个**FIN连接释放报文段**和一个随机序号（第三次挥手）
4. 客户端接收到服务器消息后，向服务器端发送一个**ACK确认报文段**和一个随机序号，服务器收到消息后，就处于关闭连接了，处于 `CLOSED` 状态（第四次挥手）

![image.png](https://img-blog.csdnimg.cn/img_convert/ae67d93bd25c900cb90fda95d2c443fa.png)

```
一般来说， ACK 报文的序列号值为对方序列号值+1
```



参考资料：

[通俗易懂了解TCP三次握手](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513094&idx=1&sn=a2accfc41107ac08d74ec3317995955e&scene=21#wechat_redirect)

[三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-0)

[如何向学妹解释在地址栏中输入网址后发生了什么？](https://juejin.cn/post/6844903806505844749#heading-6)

**扩展问题**

```
Q:说一说三次握手
三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

Q:为什么需要三次握手，两次不行吗？
弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

第一次握手：客户端发送网络包，服务端收到了。
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。


Q:挥手为什么要4次？
关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
```

### 2.CSS为什么要清除浮动？如何清除浮动？

由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。清除浮动的本质是清除浮动元素造成的影响，清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。

清除浮动的方法有：

**1.clear:both;**

在浮动元素末尾添加一个空的标签，**这个标签必须为块级元素**。然后将其设置clear:both,这样就可以清除浮动。

**优点：**简单易懂，方便。

**缺点：**添加了无意义的冗余元素，结构化差。

```html
<div class="box">
    <div class="inner"></div>
    <div class="inner"></div>
    <div class="inner"></div>
    <div style="clear:both"></div>
</div>
```

**2.伪元素清除浮动**

给父元素添加一个before或after伪元素，然后设置伪元素的样式，这是通用的清理浮动方案。

**优点：**没有增加标签，结构更简单

**缺点：**没有照顾低版本浏览器

```css
.clearfix:after { 
 content: ""; 
 display: block; 
 height: 0; 
 clear: both; 
 visibility: hidden; 
} 
.clearfix { /* IE6、7 专有 */ 
 *zoom: 1;
}
```

**3.给父元素使用overflow:hidden;**

让父容器形成了BFC（块级格式上下文），而BFC可以包含浮动，父元素的高度计算会包括浮动元素的高度。

### 3. BFC是什么，怎么样形成BFC，BFC有什么作用？

BFC （Block Formatting Context） 是**块级格式化上下文**，是**Web页面**中**盒模型布局**的**CSS渲染模式**，是一个隔离的独立容器。 

**怎样形成一个BFC？** 

由以下之一创建：

- 浮动：float元素除了none以外。

- 绝对定位的元素

- 非块级元素具有 display: inline-block，table-cell,flex等。

  块级元素具有overflow ，且值不是 **visible**

**BFC用处**

1. 清除浮动，给父元素添加overflow:hidden。因为计算BFC的高度时，浮动元素也参与计算。
2. 用于两栏自适应布局
3. 防止垂直margin合并

### 4.如何实现水平居中

#### 行内元素

1.首先看它的父元素是不是块级元素，如果是，则直接给父元素设置 **text-align: center;** 

2.如果不是，则先将其父元素设置为块级元素，再给父元素设置 **text-align: center;**

#### 块级元素

**方法1：margin**

1.如果盒子**宽度给定**，给其设置`margin: 0 auto;`（作用：使盒子自己居中）

2.如果盒子**不定宽度**，则子元素的宽度默认与父元素一样宽。这时需要设置子元素为`display: inline-block;` 或`display: inline;`即将其转换成行内块级/行内元素，给父元素设置 `text-align: center;`

**方法2：定位**

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**left:50%**，即让子元素的左上角水平居中，再分情况：

1.盒子**定宽度**，设置绝对子元素的 `margin-left: -元素宽度的一半px;`或者设置`transform: translateX(-50%);`

2.盒子**不定宽度：**利用css3新增属性`transform: translateX(-50%);`

**方法3：用flex布局**

使用flex布局，只需要给待处理的块状元素的父元素添加属性`display: flex; justify-content: center;`

### 5.如何实现盒子垂直居中

#### 单行的行内元素

只需要设置单行行内元素`line-height: 父盒子高度px;`

#### 多行的行内元素

使用给父元素设置`display:table-cell;`和`vertical-align: middle;`属即可；

```
父元素变成表格单元格，设置多行文字垂直居中
```

#### 块级元素

**方法1：定位**

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**top: 50%**，即让子元素的左上角垂直居中；

1.盒子**定高度**：设置绝对子元素的 `margin-top: -元素高度的一半px;` 或者设置`transform: translateY(-50%);`

2.盒子**不定高度：**利用css3新增属性**transform: translateY(-50%);**

**方法2：flex布局**

使用flexbox布局，只需要给待处理的块状元素的父元素添加属性`display: flex; align-items: center;`

### 6.如何实现水平垂直居中

#### 已知高度和宽度的元素

**方案一：**设置父元素为相对定位，给子元素设置绝对定位，`top: 0; right: 0; bottom: 0; left: 0; margin: auto;`

**方案二：**设置父元素为相对定位，给子元素设置绝对定位，`left: 50%; top: 50%; margin-left: -元素宽度的一半px; margin-top: -元素高度的一半px;`

#### 未知高度和宽度的元素

**方案一：**使用定位属性

设置父元素为相对定位，给子元素设置绝对定位，**left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);**

**方案二：**使用flex布局实现

设置父元素为flex定位，**justify-content: center; align-items: center;**