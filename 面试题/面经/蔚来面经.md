## 蔚来面经

### 一、笔试

就一道编程题

#### 题目

现在给出一棵树，树的结点名字表示项目的名称和版本号，用逗号分隔，例如结点名字为a,1表示项目的名称为a，版本号为1。 

每个结点的名字都是唯一的。但树里可以出现项目名称相同，但版本号不同的结点。对于某个名称的项目来说，真正有效的版本号是距离根节点最近的是这个项目名称的结点里的版本号。如果多个相同项目名称，不同版本的结点距离根节点的距离相同，则生效版本为在输入中先出现的结点的版本。 

此外，输入中给出的依赖关系可能存在循环依赖的例外情况，例如a,1依赖b,1，b,1又依赖a,1，这种情况就不是一颗有效的树。 

##### **输入描述:**

```
输入由多行组成。
第一行是要检查的项目的名称，要检查的项目必定会存在于输入中。
第二行是根节点的项目名称及版本号。
接下来每行表示两个项目之间的依赖关系。用->表示前者依赖后者，即后者是前者的子节点。
例如a,1->b,1，表示1版本的a依赖1版本的b。
结点名字由项目名称和版本号组成，用逗号分隔，项目名称是a-z的单个字符，版本号是1-9的正整数。
```

##### **输出描述:**

```
如果给的输入能组成一颗有效的树，则输出要检查的项目的生效版本号。
如果给的输入不能组成一颗有效的树，则输出-1。
```

示例1

输入

```
e a,1 b,1->e,2 c,1->e,1 a,1->b,1 a,1->c,1 a,1->d,1
```

输出

```
2
```

#### 代码

思路：

```js
function findVersion(s1, root, arr) {
  // let [s1, root, ...arr] = args[0].split(' ');
  // console.log(s1);
  // console.log(root);
  // console.log(arr);
  // console.log(args);
  function TreeNode(name, version) {
    this.name = name;
    this.version = version;
    this.children = [];
    this.parent = null;
    this.deep = 0;
  }

  //构建N叉树 建树的过程中判断是否为有效树
  var buildTree = function (root, arr) {
    //记录某结点是否创建
    let map = new Map();
    let [name, version] = root.split(',');
    //节点已经通过children 和parent链接起来，故不需要在意存储顺序
    let Nodes = [];
    let mynode = new TreeNode(name, version);
    map.set(root, mynode);
    Nodes.push(mynode);
    for (let i = 0; i < arr.length; i++) {
      let mynode1, mynode2;
      let [node1, node2] = arr[i].split('->');
      let [name1, ver1] = node1.split(',');
      let [name2, ver2] = node2.split(',');
      // console.log(node1);
      // console.log(node2);
      //如果该结点未创建
      if (!map.get(node1)) {
        // console.log(1);
        mynode1 = new TreeNode(name1, ver1);
        Nodes.push(mynode1);
        map.set(node1, mynode1);
      } else {
        // console.log(2);
        mynode1 = map.get(node1);
      }

      if (!map.get(node2)) {
        mynode2 = new TreeNode(name2, ver2);
        Nodes.push(mynode2);
        map.set(node2, mynode2);
      } else {
        mynode2 = map.get(node2);
      }

      mynode1.children.push(mynode2);
      // console.log(mynode1);
      // console.log(mynode2);

      //不是有效
      if ((mynode2.name === name && mynode2.version === version) || mynode2.parent !== null) {
        return -1;
      } else {
        mynode2.parent = mynode1;
      }
    }
    return Nodes;
  }

  var findDeep = function (arr, node) {
    let count = 0;
    while (node.parent != null) {
      count++;
      node = node.parent;
    }
    return count;
  }

  var findVersion = function (arr) {
    const res = [];
    for (let i = 0; i < arr.length; i++) {
      if (arr[i].name === s1) {
        res.push(arr[i]);
        arr[i].deep = findDeep(arr, arr[i]);
      }
    }

    res.sort((a, b) => {
      return a.deep < b.deep;
    })
    // console.log(res);
    //计算树深
    //如果树深相同，求版本号最大，如果树深不同，求最近
    //深度一样
    if (res[0].deep === res[res.length - 1].deep) {
      let max = 0;
      for (let i = 0; i < res.length; i++) {
        // console.log(res[i].version);

        if (res[i].version > max) {
          max = res[i].version;
        }
      }
      return max * 1;
    } else {
      return res[0].version * 1;
    }
  }

  var ans = buildTree(root, arr);
  if (ans === -1) {
    return -1;
  } else {
    return findVersion(ans);
  }
}
// findVersion('e a,1 e,1->e,2 c,1->e,1 a,1->b,1 a,1->c,1 a,1->d,1');
console.log(findVersion('e', 'a,1', ['b,1->e,2', 'c,1->e,1', 'a,1->b,1', 'a,1->c,1', 'a,1->d,1']));

```

### 一面

一道编程题：对一个对象数组进行数据统计，将arr转为arr2的表结构。

![image-20210402124951972](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210402124951972.png)

**代码：**

```js
const arr = [
  {
    time: '123',
    pro_id: 'vue'
  },
  {
    time: '123',
    pro_id: 'react'
  },
  {
    time: '1234',
    pro_id: 'react'
  },
  {
    time: '1234',
    pro_id: 'react'
  }
]

const arr2 = [
  ['date', 'vue', 'react'],
  ['123', '1', '1'],
  ['1234', '0', '2']
]

function change(arr) {
  //遍历获取 所有的时间和项目名并去重
  //创建一个二维数组res 并fill 0，第一行是date +项目名 date +项目=列数 时间个数+1= 行数
  //后面每一行的开头是一个日期
  //对arr进行for循环 item; x= res[0].indexof(pro_id) for(i=x;i<行数;i++) if(time === res[i][0]) res[i][x]++ break;
  let time = [];
  let name = [];
  arr.forEach(element => {
    time.push(element.time);
    name.push(element.pro_id);
  });
  time = [...new Set(time)];
  name = [...new Set(name)];
  // console.log(time);
  // console.log(name);
  let row = time.length + 1;
  let col = name.length + 1;
  const res = new Array(row);
  for (let i = 0; i < row; i++) {
    res[i] = new Array(col).fill(0);
  }
  // 初始化表头
  res[0][0] = "date";
  for (let i = 1; i < col; i++) {
    res[0][i] = name[i - 1];
  }
  for (let j = 1; j < row; j++) {
    res[j][0] = time[j - 1];
  }

  arr.forEach(item => {
    x = res[0].indexOf(item.pro_id);
    for (let i = 1; i < row; i++) {
      if (item.time === res[i][0]) {
        res[i][x]++;
        break;
      }
    }
  })
  for (let i = 0; i < row; i++) {
    console.log(res[i].join(' '));
  }
  return res;
}

console.log(change(arr));
```

### 二面

`忘记录音了，以下问题是面完之后回想的`

1、做一下自我介绍

2、聊了一下项目，挺短的，没细问

3、为什么学习前端

4、说一下js的基本数据类型

5、判断数据类型的方法（typeof），除了typeof还有别的吗

6、判断数组跟Object是否相等的方法

7、typeof null 返回什么（Object）

8、说一下instanceof的原理（原型）

9、说一下原型链

说一下0.1+0.2等于多少

10、说一下宏任务和微任务，然后做了一道事件循环的输出题

题目如下：

```js
new Promise(function(){
    console.log("promise macro task");
    resolve();
}).then(()=>{
    console.log("micro task1");
    setTimeout(()=>{
        console.log("macro task2")
    },0);
})

setTimeout(()=>{
    console.log("macro task3");
},1000);
console.log("====Syn =====");
```

**正确输出：**

```js
promise macro task
====Syn =====
micro task1
macro task2
macro task3
```

分析：

**首先执行第一个宏任务Run Script。**

1、执行Promise参数，输出 `promise macro task`，resolve后将then回调方法放入微任务中。

2、setTimeout中的函数体在1秒钟后放入宏任务中**（还没放！要等1秒）**

3、输出 `====Syn =====`

4、JS堆栈为空micro task1，查看微任务队列中是否有任务

5、微任务中有一个then方法，执行then方法中的代码，输出`micro task1`，在0秒后将setTimeout放入宏任务中。**注意：执行到现在，时间绝对没有到1s，也就是说RunScript中的setTimeout函数体还没放进宏任务中，而是then中的SetTimeout在等待0秒后（即立即放），立即放入宏任务中。**

6、微任务执行完成，该宏任务执行完成，一个Tick结束。

**第二个宏任务：setTimeout  console.log("macro task2")**

1、执行，输出 `macro task2`

2、JS堆栈为空，检查微任务，微任务为空，宏任务执行完毕，Tick结束

在1s之后，setTimeout终于放进了宏任务队列中

**第三个宏任务：setTimeout console.log("macro task3");**

1、执行，输出`macro task3`

2、JS堆栈为空，检查微任务，微任务为空，宏任务执行完毕，Tick结束

没有宏任务啦，完毕！

11、说一下页面性能优化，例如数据量很大如何处理等。（这里我说了可以使用浏览器缓存，将一些资源缓存在浏览器中，加速访问）

12、说一下浏览器缓存

13、说一下强缓存和协商缓存的实现

14、说下用户输入URL到页面显示的过程

15、说一下回流和重绘

16、如何脱离文档流

17、说一下js的async和defer

18、说一下HTTP和HTTPS的区别

19、做一道编程题：回文子串

20、还有什么问题吗



问了一下，蔚来好像只有三面，两次技术面、一次hr面。

许愿Hr面，许愿Offer。