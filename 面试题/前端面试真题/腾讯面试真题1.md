# 腾讯面试真题1

##### 1、自我介绍

开场多半都是这样

##### 2、询问你在大学学了哪些课程，你觉得你学得最好的是哪一门？

这里的话，接下来的话题就会围绕你觉得学的最好的课程来展开

##### 3、先用js手写一个冒泡排序

这期间还问了时间复杂度和空间复杂度，空间复杂度与什么因素有关

**回答：**

空间复杂度是对一个算法在运行过程中临时占用存储空间大小的量度。他的影响因素有，算法是否需要辅助空间等等。

##### 4、输入网址到网页显示的过程是什么？

```
1.URL解析
2.缓存查找
3.DNS解析
4.TCP连接，三次握手
5.http请求
6.服务器响应，浏览器解析。
7.浏览器渲染
8.TCP连接断开，4次挥手
```

从用户输入一个网址到网页最终展现，中间的大致流程如下：

（1）首先浏览器会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果URL的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会进行缓存查找。判断请求资源是否在缓存里，如果请在并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）进行DNS解析，获取URL中域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有**本地 DNS 服务器**向**根域名服务器**发起请求，获得负责的顶级域名服务器的地址后，再向**顶级域名服务器**请求，然后获得负责的权威域名服务器的地址后，再向**权威域名服务器**发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地DNS服务器发起请求属于递归请求（本地服务器会帮主机进行DNS查询，这一步对主机是透明的。因此是属于递归），本地DNS服务器向各级域名服务器发起请求属于迭代请求。（迭代的查询IP）

![img](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/169b3a2a6dfe85ec)

（4）我们通过DNS解析获取到IP地址后， 需要发起TCP连接请求。 TCP 建立连接需要经历三次握手的过程，首先客户端向服务器发送一个 **SYN 连接请求报文段**和一个随机序号，服务端接收到请求后向客户端发送一个 **SYN ACK报文段**和一个随机序号，确认连接请求。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 **ACK 确认报文段**，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

```
在TCP报文的报头中，有几个标志字段：
1、 SYN：同步连接序号，TCP SYN报文就是把这个标志设置为1，来请求建立连接；
2、 ACK：请求/应答状态。0为请求，1为应答；
3、 FIN：结束连线。如果FIN为0是结束连线请求，FIN为1表示结束连线；
```



![三次握手.png](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/16da9fd28a45bd19)

（5）握手成功后， 浏览器就可以向服务器发送**http**请求了。 **发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)**。HTTP请求报文是由三部分组成: 请求行,请求报头和请求正文。

（6）在服务端会监听浏览器端发送的http请求，当浏览器的请求发出后，服务端就会接受该请求，并对相应的信息进行处理，将处理的结果响应给浏览器端。浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（7）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局，计算每个节点的几何位置。布局完成后，进入绘制阶段，将各个节点绘制到屏幕上。这个时候整个页面就显示出来了。

（8）最后一步是 断开 TCP连接，需要经历四次挥手过程。

4次挥手大体的过程如下：

1. 客户端向服务器发送一个**FIN连接释放报文段**和一个随机序号，通知服务器现在需要断开（第一次挥手）
2. 服务器接到要断开的请求之后，向客户端发送一个**ACK确认报文段**和一个随机序号，服务端进入CLOSE_WAIT（关闭等待）状态（第二次挥手）
4. 如果服务端也想断开连接了，向客户端发送一个**FIN连接释放报文段**和一个随机序号（第三次挥手）
5. 客户端接收到服务器消息后，向服务器端发送一个**ACK确认报文段**和一个随机序号，服务器收到消息后，就处于关闭连接了，处于 `CLOSED` 状态（第四次挥手）

![image.png](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/16da9fd28b49f652)

```
一般来说， ACK 报文的序列号值为对方序列号值+1
```



参考资料：

[通俗易懂了解TCP三次握手](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513094&idx=1&sn=a2accfc41107ac08d74ec3317995955e&scene=21#wechat_redirect)

[三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-0)

[如何向学妹解释在地址栏中输入网址后发生了什么？](https://juejin.cn/post/6844903806505844749#heading-6)

**扩展问题**

```
Q:说一说三次握手
三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

Q:为什么需要三次握手，两次不行吗？
弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

第一次握手：客户端发送网络包，服务端收到了。
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。


Q:挥手为什么要4次？
关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四次挥手。
```

##### 你用过git吗？常见哪些指令？你知道回退是什么指令吗？

常用的指令有：

**克隆/关联/推送远程库**

```
$ git remote add origin ssh//关联远程库
$ git push -u origin master //本地库所有内容推送至远程库
$ git push origin master //可推送最新修改
```

**添加、提交文件**

```other
$ git add file //添加文件至暂存区
$ git commit -m"explain" //提交
//可添加多个 一次提交
```

**版本管理**

```other
$ git status //查看工作区与版本库的状态
$ git log //查看提交记录
$ git reset --hard xxx//版本回退 xxx为版本号或 HEAD^ HEAD^^ HEAD~数字 。git用HEAD表示当前版本，，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100.
```

**分支管理**

```
$ git branch //查看当前分支
$ git checkout master //切换至master分支
$ git checkout -b dev //创建dev分支并切换到dev分支
$ git merge dev //即dev合并到当前分支
$ git branch -d dev //删除分支
```

##### 你了解Webpack吗？

Webpack吗，了解一些。Webpack 是一个模块打包器。我使用 webpack 的一个最主要原因是为了简化页面依赖的管理，并且通过将其打包为一个文件来降低页面加载时请求的资源数。

我认为 webpack 的主要原理是，它将所有的资源都看成是一个模块，并且把页面逻辑当作一个整体，通过一个给定的入口文件，webpack 从这个文件开始，找到所有的依赖文件，将各个依赖文件模块通过 loader 和 plugins 处理后，然后打包在一起，最后输出一个浏览器可识别的 JS 文件。

Webpack 具有四个核心的概念，分别是 Entry（入口）、Output（输出）、loader 和 Plugins（插件）。

Entry 是 webpack 的入口起点，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。

Output 属性告诉 webpack 在哪里输出它所创建的打包文件，也可指定打包文件的名称，默认位置为 ./dist。

loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件。在对 loader 进行配置的时候，test 属性，标志有哪些后缀的文件应该被处理，是一个正则表达式。use 属性，指定 test 类型的文件应该使用哪个 loader 进行预处理。常用的 loader 有 css-loader、style-loader 等。

插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，要使用一个插件，一般是先使用 npm 包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。

使用 webpack 的确能够提供我们对于项目的管理，但是它的缺点就是调试和配置起来太麻烦了。但现在 webpack4.0 的免配置一定程度上解决了这个问题。但是我感觉就是对我来说，就是一个黑盒，很多时候出现了问题，没有办法很好的定位。

##### 你了解React吗？

不是很了解。我只知道React是一个JavaScript库，可以把它看成MVC中的V（视图）层。MVC是一种设计模式，它将应用划分为3个部分：数据(模型)、展示层(视图)和用户交互层

![img](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/a86c349b74f7422fbc392c081179b9bd~tplv-k3u1fbpfcp-zoom-1.image)

如今主流的web框架基本都采用的是MVVM模式，为什么放弃了MVC模式，转而投向了MVVM模式呢。在之前的MVC中我们提到一个控制器对应一个视图，控制器用状态机进行管理，这里就存在一个问题，如果项目足够大的时候，状态机的代码量就变得非常臃肿，难以维护。还有一个就是性能问题，在MVC中我们大量的操作了DOM，而大量操作DOM会让页面渲染性能降低，加载速度变慢，影响用户体验。最后就是当Model频繁变化的时候，开发者就主动更新View，那么数据的维护就变得困难。世界是懒人创造的，为了减小工作量，节约时间，一个更适合前端开发的架构模式就显得非常重要。这时候MVVM模式在前端中的应用就应运而生。 MVVM让用户界面和逻辑分离更加清晰。下面是MVVM的示意图，可以看到它由Model、ViewModel、View这三个部分组成。

![img](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/161b8195912e4305)

Vue,React,Angular都是业界非常优秀的前端框架，我一开始是学了Vue。原因有几点：

首先，Vue是比较轻量级的框架，比较好上手，对新手来说比较友好。

其次，Vue有响应式更新机制，就是说当我们的数据更新之后，视图会自动的刷新。React的话好像需要进行一个性能优化，Vue这个响应式更新机制它已经在底层去帮我们去处理这些事情。

我认为学习Vue是一个跳板，当一个比较好上手的框架你会使用了之后，就能更好地学习其它框架。这就是我学习Vue的一些原因。

##### 你知道gulp吗？

###### webpack与grunt、gulp的不同？

三者都是前端构建工具，grunt和gulp在早期比较流行，现在webpack相对来说比较主流，不过一些轻量化的任务还是会用gulp来处理，比如单独打包CSS文件等。

grunt和gulp基于任务和流（Task、Stream），强调的是前端流程的自动化。比如定义一系列的task让grunt或gulp来依次执行，让整个流程自动化，grunt和gulp也被称作前端自动化任务管理工具。

而webpack（静态模块打包工具）基于入口，强调的是前端模块化开发管理。它是把一个项目当做一个整体，通过一个给定的入口，Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders、plugins进行一些处理，最后打包为一个（或多个）浏览器可识别的Javascript文件。

##### 谈谈你对响应式原理的理解