## 真题题目大杂烩

### 真题1

#### Symbol类型是做什么的

`Symbol` 是 `ES6` 新推出Plugin的一种基本类型，它表示独一无二的值。它最大的用途就是用来定义对象唯一的属性名。

#### 如何定义对象唯一的属性名。

由于 Symbol 值是独一无二的值，所以我们可以把它作为对象的属性名，就能保证不会出现同名的属性，还能防止某一个属性被不小心覆盖。

通过Symbol()方法可以生成一个symbol，里面可以带参数，也可以不带参数

```js
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

```
Symbol 类型的注意点
 
- 1.Symbol 函数前不能使用 new 命令，否则会报错。
- 2.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。
- Symbol值不能与其他类型值运算，不能转数值；可以转字符串和布尔值
- 不能用.运算符，要用方括号
- `Symbol名.description`，直接返回 Symbol 的描述。
- 3.Symbol 作为属性名时，该属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys() 返回。
- 4.Object.getOwnPropertySymbols 方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。
- 5.Symbol.for 接受一个字符串作为参数，首先在全局中搜索有没有以该参数为名称的Symbol值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。
```

##### Symbol和Symbol.for的区别

`Symbol.for()`与`Symbol()`这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。比如，如果你调用`Symbol.for("1")`30 次，每次都会返回同一个 Symbol 值，但是调用`Symbol("1")`30 次，会返回 30 个不同的 Symbol 值。

#### 列举ES6的新特性并说一下如何使用

```
变量：let const 块级
函数：箭头 Promise Generator async/await Proxy
字符串：模板字符串
数组：for of
对象: 解耦复制、对象属性方法简写
运算符：剩余运算符、扩展运算符
类：class
```



##### 1.const 与 let以及var以及块级作用域

具体如何使用

三者使用的区别

- 变量提升：var声明会被变量提升到函数顶部，let和const声明不会提升。

- 作用域：var是函数作用域；let和const是块级作用域, 在{}里就形成了一个作用域

```
块级作用域,也就是在{}内部声明的变量只能够在{}内部访问到，在{}外部无法访问到其内部声明的变量，
```

**const是常量**

const声明一个只读的常量，一旦声明，常量的值就不能改变。但const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，`const`只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。

**let和const没有变量提升，会存在暂时性死区**

```
var tmp = 123;
if (true) {
  tmp = 'abc'; // ReferenceError
  let tmp;
}
```

比如，存在全局变量`temp`，但是块级作用域内`let`又声明了一个局部变量`temp`，局部变量就绑定这个块级作用域，所以在`let`声明变量前，对`temp`赋值会报错。

##### 2.箭头函数

ES6 中，箭头函数就是函数的一种简写形式，使用括号包裹参数，跟随一个 =>，紧接着是函数体；

具体的使用细节：

箭头函数和普通函数的区别

- 箭头函数不绑定arguments，取而代之用rest参数...代替arguments对象，来访问箭头函数的参数列表。
- 箭头函数没有prototype属性，不能用作构造函数，即不可以使用new 关键字来实例化对象，否则会抛出一个错误。
- 箭头函数没有自己的this，箭头函数的this指向在定义的时候继承自外层第一个普通函数的this。
- 普通函数可以使用call修改this。但箭头函数不能用call、apply修改里面的this

>- new发生了什么

##### 3.Promise（常用）

Promise的出现改变了JS的异步编程，现在基本上异步请求都是使用Promise实现。

Promise的出现主要是为了解决回调地狱的问题。

回调地狱就是多层嵌套的问题。 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性，需要多次异步请求的话，就会显得代码跳跃且乱。

具体的使用的话：

Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。

一个 Promise 实例有三种状态，分别是 pending、fulfilled 和 rejected，分别代表了进行中、成功和失败。实例的状态只能由进行中转变成功或者进行中转失败，并且状态一经改变，就无法再被改变了。

状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。

Promise的原型上定义了一个 then 方法， 分别是成功和失败的回调。我们可以使用这个 then 方法可以为两个状态的改变注册回调函数。

这样子我们创建了一个最基本的promise。

>- 实现一下Promise

##### 12.Generator

Generator 函数也是 ES6 提供的一种异步编程解决方案。

在第一次调用Generator函数的时候并不会执行函数内部的代码，而是会返回一个生成器对象。而每次调用`next`方法则将函数执行到下一个`yield`的位置，同时向外界返回yield关键字后面的结果。如此往复，直到Generator函数内部的代码执行完毕或return。

`yield`表达式本身没有返回值，或者说总是返回`undefined`。但是`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。

ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。

```
- yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。

- for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。但是需要注意的是，一旦next方法的返回对象的done属性为true

-执行生成器对象的[Symbol.iterator]方法会返回生成器对象本身。
```

```js
function* greet() {}
let g = greet()
console.log(g[Symbol.iterator]() === g) // true
```

##### 4.模板字符串

ES6新增了模板字符串，用反引号(``)表示，可以用于定义多行字符串，或者在字符串中嵌入变量。如果要在模板字符串中嵌入变量，需要将变量名写在${}之中。

##### 5.for ... of循环

for ... of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构并且返回各项的值。它与for ... in的区别如下：

1. for ... of获取的是迭代器返回的value值,  for ... in 可以获取对象的键名。
2. 对于数组的遍历，for ... in会返回数组中所有可枚举的属性， for ... of只返回数组的下标对应的属性值

##### 6.对象属性/方法简写

- es6允许当对象的属性和值相同时，省略属性名
- es6允许当一个对象的属性的值是一个方法时，可以使用简写的形式。省略了:function

##### 7.Module模块化

import导入，export导出。ES6 Module是静态的，也就是说它是在编译阶段运行，和var以及function一样具有提升效果。

**import()动态加载。**把import作为一个函数可以实现动态加载模块，它返回一个Promise，Promise被resolve时的值为输出的模块。Vue中路由的懒加载的ES6写法就是使用了这个技术,使得在路由切换的时候能够动态的加载组件渲染视图。

>- 什么是模块化开发

```
我对模块的理解是，一个模块是实现一个特定功能的一组方法。在最开始的时候，js 只实现一些简单的功能，所以并没有模块的概念，但随着程序越来越复杂，代码的模块化开发变得越来越重要。
```

##### 8.解构赋值

我对于数组解构原理的理解是，从数组中提取值，按照对应位置，对变量赋值。对象解构原理的理解是，通过键找键，找到了相同的属性名就赋值了。

##### 9.剩余运算符rest/扩展运算符

**扩展运算符**

以数组为例,使用扩展运算符可以"展开"一个数组，可以把这些元素集合放到另外一个数组里面。

**剩余运算符**

消耗3个点后面的数组的所有迭代器，读取后面所有迭代器的value属性，放到右边的数组中。

>- 什么是迭代器

##### 10.类（Class）

ES6 引入了class（类），让JavaScript的面向对象编程变得更加简单和易于理解。比如说，构造函数、继承、super、this之类的都跟Java、C++很像。

##### 11.Proxy

Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作。

Proxy 可以理解成，在目标对象之前设置了一层“拦截”，当该对象被访问的时候，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。

具体的使用的话

一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target是目标对象， handler 是一个对象，声明了代理 target 的指定行为。

```js
let target = {
    name: 'Tom',
    age: 24
};

let handler = {
    get: function (target, key) {
        console.log('getting ' + key);
        return target[key];//不是target.key
    },
    set: function (target, key, value) {
        console.log('setting ' + key);
        target[key] = value;
    }
}

let proxy = new Proxy(target, handler);
console.log(proxy.name);//实际上执行了handler.get
// 输出：
//getting name
//Tom
proxy.age = 25;//实际上执行了handler.set
//setting age
//getting age
```

#### Promise的实现原理

promise的实现原理，Promise内部有一个变量记录当前状态为pending、fulfilled还是rejected，还有两个队列保存成功的回调和失败的回调。

当在Promise中调用resolve之后，如果当前状态为pending，则状态由pending转fulfilled，记录传入值，并依次执行成功回调；若在Promise中调用reject，如果当前状态为pending，则状态由pending转rejected，记录传入值，并依次执行失败回调。这就是resolve和reject的实现原理。

特殊情况判断.....

then方法的话，它允许注册成功、失败两个回调函数，如果当前状态为pending，则分别放入成功、失败回调数组中；如果为fulfilled，则执行成功回调；如果是rejected，则执行失败回调，最后返回this。

特殊情况判断....

#### 手写一个 Promise/实现一下Promise

**最简单**

```js
//判断变量是否为function
const isFunction = value => typeof value === 'function';
//定义状态常量
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class MyPromise {
  //构造方法
  constructor(handle) {
    if (!isFunction(handle)) {
      throw new Error('Promise must accept function param');
    }
    this.status = PENDING;
    this.value = undefined;
    // 用于保存 resolve 的回调函数
    this.fulfilledCallbacks = [];
    // 用于保存 reject 的回调函数
    this.rejectedCallbacks = [];
    //执行handle
    try {
      handle(this._resolve.bind(this), this._reject.bind(this));
    } catch (error) {
      this.reject(err);
    }
  }
  //resolve的函数
  _resolve(value) {
    setTimeout(() => {
      if (this.status !== PENDING) return;
      this.status = FULFILLED;
      this.value = value;
      this.fulfilledCallbacks.forEach(callback => {
        callback(value)
      })
    }, 0)
  }

  //reject的函数
  _reject(err) {
    setTimeout(() => {
      if (this.status !== PENDING) return;
      this.status = REJECTED;
      this.value = err;
      this.rejectedCallbacks.forEach(callback => {
        callback(err);
      })
    }, 0);
  }

  // then方法
  then(onFulfilled, onRejected) {
    const { value, status } = this;
    // 返回一个新的Promise对象
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      switch (status) {
        case PENDING:
          this.fulfilledCallbacks.push(onFulfilled);
          this.rejectedCallbacks.push(onRejected);
          break;
        //状态改变，则立即执行对应的回调函数
        case FULFILLED:
          onFulfilled(value)
          break;
        case REJECTED:
          onRejected(value)
          break;
      }
    })
  }
}

let promise1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve('这里返回一个普通值')
  }, 1000)
})
promise1.then(res => {
  console.log(res) //1秒后打印出：这里返回一个普通值
})
```

**简易Promise，仅实现_resolve _reject then。但有各种情况的判断**

```js
// 判断变量否为function
const isFunction = variable => typeof variable === 'function'
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  constructor(handle) {
    if (!isFunction(handle)) {
      throw new Error('MyPromise must accept a function as a parameter')
    }
    // 添加状态
    this._status = PENDING
    // 添加状态
    this._value = undefined
    // 添加成功回调函数队列
    this._fulfilledQueues = []
    // 添加失败回调函数队列
    this._rejectedQueues = []
    // 执行handle
    try {
      handle(this._resolve.bind(this), this._reject.bind(this))
    } catch (err) {
      this._reject(err)
    }
  }
  // 添加resovle时执行的函数
  _resolve(val) {
    const run = () => {
      if (this._status !== PENDING) return
      // 依次执行成功队列中的函数，并清空队列
      const runFulfilled = (value) => {
        let cb;
        while (cb = this._fulfilledQueues.shift()) {
          cb(value)
        }
      }
      // 依次执行失败队列中的函数，并清空队列
      const runRejected = (error) => {
        let cb;
        while (cb = this._rejectedQueues.shift()) {
          cb(error)
        }
      }
      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
      */
      if (val instanceof MyPromise) {
        val.then(value => {
          this._value = value
          this._status = FULFILLED
          runFulfilled(value)
        }, err => {
          this._value = err
          this._status = REJECTED
          runRejected(err)
        })
      } else {
        this._value = val
        this._status = FULFILLED
        runFulfilled(val)
      }
    }
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0)
  }
  // 添加reject时执行的函数
  _reject(err) {
    if (this._status !== PENDING) return
    // 依次执行失败队列中的函数，并清空队列
    const run = () => {
      this._status = REJECTED
      this._value = err
      let cb;
      while (cb = this._rejectedQueues.shift()) {
        cb(err)
      }
    }
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0)
  }
  // 添加then方法
  then(onFulfilled, onRejected) {
    const { _value, _status } = this
    // 返回一个新的Promise对象
    // 返回的新的 Promise 对象的状态依赖于当前 then 方法回调函数执行的情况以及返回值，
    // 例如 then 的参数是否为一个函数、回调函数执行是否出错、返回值是否为 Promise 对象。
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      // 封装一个成功时执行的函数
      let fulfilled = value => {
        try {
          //onFulfilled不是函数且此时promise1成功，新Promise状态变为fulfilled，且promise1的value作为其参数
          if (!isFunction(onFulfilled)) {
            onFulfilledNext(value)
          } else {
            //执行onFulfilled成功回调函数，获取返回值
            let res = onFulfilled(value);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              // 为什么传入onFulfilledNext, onRejectedNext：
              // 因为 res这个Promise的状态决定then返回的新Promise的状态，resolve时，then返回的新Promise也resolve
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              // 否则会将返回结果直接作为参数，传入resolve中
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err)
        }
      }
      // 封装一个失败时执行的函数
      let rejected = error => {
        try {
          //如果不是函数，新对象状态变为rejected，以上一个promise1的返回值为参数
          if (!isFunction(onRejected)) {
            onRejectedNext(error)
          } else {
            //执行失败promise1的回调函数
            let res = onRejected(error);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err)
        }
      }
      switch (_status) {
        // 当状态为pending时，将then方法回调函数加入执行队列等待执行
        case PENDING:
          this._fulfilledQueues.push(fulfilled)
          this._rejectedQueues.push(rejected)
          break
        // 当状态已经改变时，立即执行对应的回调函数
        case FULFILLED:
          fulfilled(_value)
          break
        case REJECTED:
          rejected(_value)
          break
      }
    })
  }
}
```

**完整版Promise**

```js
// 判断变量否为function
const isFunction = variable => typeof variable === 'function'
// 定义Promise的三种状态常量
const PENDING = 'PENDING'
const FULFILLED = 'FULFILLED'
const REJECTED = 'REJECTED'

class MyPromise {
  constructor(handle) {
    if (!isFunction(handle)) {
      throw new Error('MyPromise must accept a function as a parameter')
    }
    // 添加状态
    this._status = PENDING
    // 添加状态
    this._value = undefined
    // 添加成功回调函数队列
    this._fulfilledQueues = []
    // 添加失败回调函数队列
    this._rejectedQueues = []
    // 执行handle
    try {
      handle(this._resolve.bind(this), this._reject.bind(this))
    } catch (err) {
      this._reject(err)
    }
  }
  // 添加resovle时执行的函数
  _resolve(val) {
    const run = () => {
      if (this._status !== PENDING) return
      // 依次执行成功队列中的函数，并清空队列
      const runFulfilled = (value) => {
        let cb;
        while (cb = this._fulfilledQueues.shift()) {
          cb(value)
        }
      }
      // 依次执行失败队列中的函数，并清空队列
      const runRejected = (error) => {
        let cb;
        while (cb = this._rejectedQueues.shift()) {
          cb(error)
        }
      }
      /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,
        当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态
      */
      if (val instanceof MyPromise) {
        val.then(value => {
          this._value = value
          this._status = FULFILLED
          runFulfilled(value)
        }, err => {
          this._value = err
          this._status = REJECTED
          runRejected(err)
        })
      } else {
        this._value = val
        this._status = FULFILLED
        runFulfilled(val)
      }
    }
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0)
  }
  // 添加reject时执行的函数
  _reject(err) {
    if (this._status !== PENDING) return
    // 依次执行失败队列中的函数，并清空队列
    const run = () => {
      this._status = REJECTED
      this._value = err
      let cb;
      while (cb = this._rejectedQueues.shift()) {
        cb(err)
      }
    }
    // 为了支持同步的Promise，这里采用异步调用
    setTimeout(run, 0)
  }
  // 添加then方法
  then(onFulfilled, onRejected) {
    const { _value, _status } = this
    // 返回一个新的Promise对象
    return new MyPromise((onFulfilledNext, onRejectedNext) => {
      // 封装一个成功时执行的函数
      let fulfilled = value => {
        try {
          if (!isFunction(onFulfilled)) {
            onFulfilledNext(value)
          } else {
            let res = onFulfilled(value);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err)
        }
      }
      // 封装一个失败时执行的函数
      let rejected = error => {
        try {
          if (!isFunction(onRejected)) {
            onRejectedNext(error)
          } else {
            let res = onRejected(error);
            if (res instanceof MyPromise) {
              // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调
              res.then(onFulfilledNext, onRejectedNext)
            } else {
              //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数
              onFulfilledNext(res)
            }
          }
        } catch (err) {
          // 如果函数执行出错，新的Promise对象的状态为失败
          onRejectedNext(err)
        }
      }
      switch (_status) {
        // 当状态为pending时，将then方法回调函数加入执行队列等待执行
        case PENDING:
          this._fulfilledQueues.push(fulfilled)
          this._rejectedQueues.push(rejected)
          break
        // 当状态已经改变时，立即执行对应的回调函数
        case FULFILLED:
          fulfilled(_value)
          break
        case REJECTED:
          rejected(_value)
          break
      }
    })
  }
  // 添加catch方法
  catch(onRejected) {
    return this.then(undefined, onRejected)
  }
  // 添加静态resolve方法
  static resolve(value) {
    // 如果参数是MyPromise实例，直接返回这个实例
    if (value instanceof MyPromise) return value
    return new MyPromise(resolve => resolve(value))
  }
  // 添加静态reject方法
  static reject(value) {
    return new MyPromise((resolve, reject) => reject(value))
  }
  // 添加静态all方法
  static all(list) {
    return new MyPromise((resolve, reject) => {
      /**
       * 返回值的集合
       */
      let values = []
      let count = 0
      //entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。
//迭代对象中数组的索引值作为 key， 数组元素作为 value。

      for (let [i, p] of list.entries()) {
        // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve
        this.resolve(p).then(res => {
          values[i] = res
          count++
          // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled
          if (count === list.length) resolve(values)
        }, err => {
          // 有一个被rejected时返回的MyPromise状态就变成rejected
          reject(err)
        })
      }
    })
  }
  // 添加静态race方法
  static race(list) {
    return new MyPromise((resolve, reject) => {
      for (let p of list) {
        // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变
        this.resolve(p).then(res => {
          resolve(res)
        }, err => {
          reject(err)
        })
      }
    })
  }
  finally(cb) {
    return this.then(
      value => MyPromise.resolve(cb()).then(() => value),
      reason => MyPromise.resolve(cb()).then(() => { throw reason })
    );
  }
}
```

#### call() 、apply() 和bind()的区别？

apply 、 call 、bind 三者都是用来改变函数的this对象的指向的。

**apply**

apply() 方法调用一个函数, 其具有一个指定的this值，以及作为一个数组提供的参数

**语法：**

```js
fun.apply(thisArg, [argsArray])
```

- thisArg：在 fun 函数运行时指定的 this 值。需要注意的是，指定的 this 值并不一定是该函数执行时真正的 this 值，如果这个函数处于非严格模式下，则指定为 null 或 undefined 时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的 this 会指向该原始值的自动包装对象。

- argsArray：一个数组或者类数组对象，其中的数组元素将作为单独的参数传给 fun 函数。如果该参数的值为null 或 undefined，则表示不需要传入任何参数。

**call**

其实 apply 和 call 基本类似，他们的区别只是传入的参数不同。

**语法：**

```js
fun.call(thisArg[, arg1[, arg2[, ...]]])
```

所以 apply 和 call 的区别是 call 方法接受的是若干个参数列表，而 apply 接收的是一个包含多个参数的数组。

**bind**、

```
function.bind(thisArg[, arg1[, arg2[, ...]]])
```

bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值，在调用新函数时，它可以接受若干个参数列表。



#### this

在es5中，this 的指向并不是在创建的时候就可以确定的，this 永远指向最后调用它的那个对象。

#### 构造函数的new都做了些什么？

1.  首先创建了一个新的空对象 
2.  设置原型，将对象的原型设置为函数的 prototype 对象。
3.  让函数的 this 指向这个对象，执行构造函数的代码
4.  最终返回该对象实例。

因为箭头函数既没有prototype，也没有自己的``this``，它的``this``其实是继承了外层执行环境中的``this``，且`this`指向永远不会改变，所以箭头函数不能作为构造函数使用，用new调用时会报错！

#### 介绍各个数据结构的特点

**二叉树**是每个节点最多有两个子树的树结构，通常子树被称作“左子树”和“右子树”。

**栈**是先进后出的结构。

**队列**是先进先出的结构。

**堆**实质上是一个完全二叉树，它的根节点是最大值或最小值。每个的节点元素值不小于其子节点 - 最大堆；每个的节点元素值不大于其子节点 - 最小堆

**链表**是用一组任意存储的单元来存储线性表的数据元素。一个对象存储着本身的值和下一个元素的地址。

#### 二叉树是什么，有几种遍历，分别怎么实现之类的

简单，略

#### js执行机制--Event loop

js是单线程的，js设计者把任务分为同步任务和异步任务，所有同步任务都在主线程上执行，前面任务没有执行完成，后面的任务会一直等待；异步任务则是挂在在一个任务队列里，等待主线程所有任务执行完成后，通知任务队列可以把可执行的任务放到主线程执行。异步任务放到主线程执行完后，又通知任务队列把下一个异步任务放到主线程中执行。这个过程一直持续，直到异步任务执行完成，这个持续重复的过程就叫Event loop。而一次循环就是一次tick 。

>- 什么是tick

在任务队列中的异步任务又可以分为两种**microtast（微任务）** 和**macrotask（宏任务）**，执行优先级上，先执行宏任务macrotask，再执行微任务mincrotask。

常见的macrotask有：

- `run <script>（同步的代码执行）`
- `setTimeout`
- `setInterval`
- `setImmediate (Node环境中)`
- `requestAnimationFrame`
- `I/O`

- `UI rendering`

常见的microtask有：

- `process.nextTick (Node环境中)`
- `Promise callbacks` 

- `Object.observe (基本上已经废弃)`
- `MutationObserver`
- await下面的语句

>- async函数里面await标记之前的语句和 await 后面的语句是**同步**执行的。
>  后面的语句是**异步**的，丢进Micro
>
>- new Promise在实例的过程中执行代码都是同步进行的，只有回调.then()才是微任务。
>- **注意：Promise中resolve之后，代码还会执行，除非在resolve的同时return**

**Q：**

```js
setTimeout(() => {
  console.log('真的在300ms后打印吗？')
}, 300)
```

**A：**不一定是精确的300ms之后打印。因为300ms的setTimeout并不是说300ms之后立马执行，而是300ms之后被放入任务列表里面。等待事件循环，等待它执行的时候才能执行代码。

#### 介绍一下JS的事件循环。

要说JS的事件循环，先得了解JS的执行机制，JS的执行机制是，所有同步任务都在主线程上执行, 形成一个执行栈(stack)。所有的异步任务，不进入主线程、而进入"任务队列"，异步任务有setTimeout等等，等待同步任务执行完毕之后，轮询执行任务队列中的异步任务。

除了同步任务、异步任务，还有宏任务和微任务，宏任务队列等同于我们常说的任务队列，微任务，总是添加到当前任务队列末尾执行。

**JS事件循环：**
     JS 会创建一个类似于 `while (true)` 的循环，顺序执行宏任务，当宏任务的JS堆栈清空之后，执行微任务。微任务清空即为一个宏任务的完成，接着执行另一个宏任务，直至宏任务清空。

#### JS是如何实现异步的？

 JS是单线程的，JS能实现异步的原因在于事件循环和任务队列体系。

JS的执行机制是，所有同步任务都在主线程上执行, 形成一个执行栈(stack)。所有的异步任务，不进入主线程、而进入"任务队列"，异步任务有setTimeout等等，等待同步任务执行完毕之后，轮询执行任务队列中的异步任务。

除了同步任务、异步任务，还有宏任务和微任务，宏任务队列等同于我们常说的任务队列，微任务，总是添加到当前任务队列末尾执行。

**JS事件循环：**
     JS 会创建一个类似于 `while (true)` 的循环，顺序执行宏任务，当宏任务的JS堆栈清空之后，执行微任务。微任务清空即为一个宏任务的完成，接着执行另一个宏任务，直至宏任务清空。

```
先说一下几个概念：同步任务、异步任务、任务队列、macrotask、microtask。

同步任务指的是在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。

异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，等待同步任务执行完毕之后，轮询执行异步任务队列中的任务。

macrotask 宏任务，宏任务队列等同于我们常说的任务队列，

"任务队列"是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。

microtask 微任务，**总是添加到当前任务队列末尾执行**。如果在处理microtask期间，如果有新添加的microtasks，也会被添加到队列的末尾并执行。

**事件循环：**
     JS 会创建一个类似于 `while (true)` 的循环，JS顺序执行宏任务，当宏任务的JS堆栈清空之后，执行微任务。微任务清空即为一个宏任务的完成，接着执行另一个宏任务。
```

![image-20201214092953116](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20201214092953116.png)

顺序执行宏任务，当宏任务的JS堆栈清空之后，执行微任务。微任务清空即为一个宏任务的完成，接着执行另一个宏任务。



#### 手写call 、apply 、bind方法

**实现call方法思路**

1.在Function原型上增加_call方法，接受两个参数。第一个参数为指定的this值，默认值为window；第二个参数使用剩余运算符展开，获取参数列表。

2.将函数this设置为context对象的属性，通过隐式绑定的方式调用函数，把context上的属性删了，并返回函数调用的返回值

>- 这里的原理是：this指向调用它的对象，这是是context调用，所以this指向了context。
>
>- 为什么要删除context上的属性。
>
>  防止这个属性对context造成影响，而且这个属性本身也没有用啦，不用留着占内存，

**实现apply方法思路**

1.在Function原型上增加_apply方法，接受两个参数。第一个参数为指定的this值，默认值为window；第二个参数接受一个数组，默认值为空数组

2.将函数this设置为context对象的属性，通过隐式绑定的方式调用函数，把context上的属性删了，并返回函数调用的返回值

**实现bind方法思路**

bind方法的实现可以参考apply。bind和apply的区别在于，bind是返回一个绑定好的函数，apply是直接调用。那么实现也很简单，就是返回一个函数，里面执行了apply的操作而已。

不过有一个需要判断的点，因为返回新的函数，要考虑到使用new去调用，并且在this绑定中new的优先级比较高，所以需要判断new的调用，还有一个特点就是bind调用的时候可以传参，调用之后生成的新的函数也可以传参，效果是一样的，所以这一块也要做处理。

您已实现了apply 和 call ，那么bind 直接调用apply 或者 call 会更加优雅。 

```js
Function.prototype._call = function (context = window, ...args) {
  // 判断调用对象
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  args = args ? args : []
  //创建独一无二属性，以免覆盖原属性
  const key = Symbol();
  context[key] = this;
  //通过隐式绑定的方式调用函数
  const result = context[key](...args);
  //删除添加的属性
  delete context[key];
  //返回函数调用的返回值
  return result;
};

// 第二个参数是数组
Function.prototype._apply = function (context = window, args = []) {
  // 判断调用对象
  if (typeof this !== 'function') {
    throw new TypeError('Error');
  }
  const key = Symbol();
  context[key] = this;
  //通过隐式绑定的方式调用函数
  const result = context[key](...args);
  //删除添加的属性
  delete context[key];
  //返回函数调用的返回值
  return result;
};

Function.prototype._bind = function (context, ...args) {
  if (typeof this !== 'function') { 
    throw new TypeError('Error');
  }
  //返回一个绑定this的函数，我们需要在此保存this
  const fn = this;
  return function newFn(...newFnArgs) {
    //如果使用new调用，此时的this执行实例对象
    if (this instanceof newFn) {
      //直接new函数，此时的this指向函数本身
      return new fn(...args, ...newFnArgs)
    }
    //使用apply修改this指向
    return fn.apply(context, [...args, ...newFnArgs])
  }
};


let obj = { x: 1 };
function fn() {
  console.log(this.x, arguments);
}
fn._call(obj, 1, 2, 3);
fn._apply(obj, [1, 2, 3]);

const bindFn = fn._bind(obj, 1, 2, 3);
bindFn();
```

### 真题2 

#### Vue是如何监听数据变化并触发视图更新的/阐述一下你所理解vue的MVVM响应式原理/vue 双向数据绑定原理

vue 是采用数据劫持结合发布者-订阅者模式的方式，通过`Object.defineProperty()`来劫持各个属性的`setter`，`getter`，在数据变动时发布消息给订阅者，触发相应的监听回调。

主要分为以下几个步骤：

1、需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化。

2、compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图

3、Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 

①在自身实例化时往属性订阅器(dep)里面添加自己

 ②自身有一个update()方法 

③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调。

MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -> 视图更新；视图交互变化(input) -> 数据model变更的双向绑定效果。

```
数据监听器Observer,能够对数据对象的所有属性进行监听，如有变动可拿到最新值通知依赖收集对象(Dep)并通知订阅者(Watcher)来更新视图。
Dep(订阅器)
```

![image-20210406141903338](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141903338.png)

在Vue2.X版本中，响应式布局一个最重要的API就是Object.defineProperty，用这个API用来做数据劫持。而在Vue3.0对数据的收集劫持用到了Proxy，代替了definePropety。

>- 为什么Vue3.0重写数据监听机制，使用Proxy代替defineProperty。
>
>原因在于 defineProperty本身有一些缺陷：
>
>1.无法原生监听数组的变化，需要特殊处理
>
>2.必须遍历对象的每个属性（当示例初始化的时，Object.definePropety是从data的根节点遍历到末节点。一次性便利全部)
>
>3.无法监听属性的新增删除操作（VUE提供Vue.set Vue.delete API，原因就是因为Object.definePropety无法监听新增删除操作）
>
>Proxy可以监听数组，也可以监听属性的新增删除操作。但是也存在缺点，ES6的`Proxy`无法被转译为ES5，所以它将不被IE所支持，现在Vue3.0只给出了IE11的兼容方案，IE11以下还是得使用`Object.defineProperty`机制
>
>- 什么是Proxy

#### 简历上说你对ES6有了解，能跟我说说ES6中的异步请求吗？并且解决了什么问题？/ES6的异步编程的实现方式。/如何理解JS的异步编程

```
Promise Generator Async/Await
```

ES6中一共有三种异步编程解决方案：Promise、 Generator、Async/Await

**Promise**

Promise的出现改变了JS的异步编程，Promise的出现主要是为了解决回调地狱的问题。

具体的使用的话：

Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。

一个 Promise 实例有三种状态，分别是 pending、fulfilled 和 rejected，分别代表了进行中、成功和失败。实例的状态只能由进行中转变成功或者进行中转失败，并且状态一经改变，就无法再被改变了。

状态的改变是通过 resolve() 和 reject() 函数来实现的，我们可以在异步操作结束后调用这两个函数改变 Promise 实例的状态。

Promise的原型上定义了一个 then 方法， 分别是成功和失败的回调。我们可以使用这个 then 方法可以为两个状态的改变注册回调函数。

这样子我们创建了一个最基本的promise。

Promise他是采取了链式编程，比不断地嵌套直观得多，通过将嵌套转链式实现异步请求。

>- 实现一下Promise
>- 什么是回调地狱

**Generator**

Generator 函数也是 ES6 提供的一种异步编程解决方案。使用Generator函数来进行异步请求的基本思想就是在执行异步操作时暂停生成器函数的执行，然后在阶段性异步操作完成的回调中通过生成器对象的next方法让Generator函数从暂停的位置恢复执行，如此往复直到生成器函数执行结束。

在第一次调用Generator函数的时候并不会执行函数内部的代码，而是会返回一个生成器对象。而每次调用`next`方法则将函数执行到下一个`yield`的位置，同时向外界返回yield关键字后面的结果。如此往复，直到Generator函数内部的代码执行完毕或return。

`yield`表达式本身没有返回值，或者说总是返回`undefined`。但是`next`方法可以带一个参数，该参数就会被当作上一个`yield`表达式的返回值。

ES6 提供了`yield*`表达式，作为解决办法，用来在一个 Generator 函数里面执行另一个 Generator 函数。

```
- yield表达式只能用在 Generator 函数里面，用在其他地方都会报错。

- for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用next方法。但是需要注意的是，一旦next方法的返回对象的done属性为true

-执行生成器对象的[Symbol.iterator]方法会返回生成器对象本身。
```

```js
function* greet() {}
let g = greet()
console.log(g[Symbol.iterator]() === g) // true
```

**async/await**

ES7引入的async函数，是对js异步请求的进一步完善。async/await不再需要执行器，执行async函数，就会自动执行函数内部的逻辑。await后面既可以是promise也可以是任意类型的值，此时等同于同步操作。

**实际应用**

我在Vue项目中，使用axios发起HTTP请求时，使用了async / await发起异步请求。一开始，我使用axios发起HTTP请求的时候报错，原因是我发起HTTP请求没有做任何修饰操作，这时候请求没完成，我就判断它的返回的状态码，获取不到，所以报错了。

#### 什么是回调地狱

回调地狱就是多层嵌套的问题。 每种任务的处理结果存在两种可能性（成功或失败），那么需要在每种任务执行结束后分别处理这两种可能性，需要多次异步请求的话，就会显得代码跳跃且乱。

#### 看到你简历上说对Webpack了解，熟悉到什么程度?webpack主要解决的问题是什么?

我可以使用webpack实现项目的基础脚手架的配置，并做一些webpack打包过程的性能优化。

webpack主要解决的问题就是**如何更高效地管理和维护项目中的每一个资源**。它通过分析项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言，并将其转换和打包为合适的格式供浏览器使用。

```js
module.exports = {
  // 入口配置
  entry: './src/main.js',
  // 出口配置
  output: {
    // 动态获取路径 
    // 注意是两个下划线
    // __dirname获取当前文件所在路径
    path: path.resolve(__dirname, "dist"),
    filename: 'bundle.js',
  },
  module: {
    rules: [
      {
        test: /\.css$/,
        use: ['style-loader', 'css-loader']
      },
      {
        test: /\.less$/,
        use: [{
          loader: "style-loader" // creates style nodes from JS strings
        }, {
          loader: "css-loader" // translates CSS into CommonJS
        }, {
          loader: "less-loader" // compiles Less to CSS
        }]
      }
    ]
  },
  plugins: [
    new xxxPlugin(),
    new xxxPlugin()
  ]
}

```

### 谈谈你对webpack的看法

webpack是一个前端模块化打包工具，可以使用它管理项目中的模块依赖，并编译输出模块所需的静态文件，它可以让开发更高效。

webpack主要解决的问题就是**如何更高效地管理和维护项目中的每一个资源**。它通过分析项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言，并将其转换和打包为合适的格式供浏览器使用。

#### 有哪些常见的Loader？你用过哪些Loader？他们是解决什么问题的？

- css-loader：加载 CSS，支持模块化、压缩、文件导入等特性

- style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。

- file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件

- url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去

- image-loader：加载并且压缩图片文件

- babel-loader：把 ES6 转换成 ES5

- eslint-loader：通过 ESLint 检查 JavaScript 代码

#### 有哪些常见的Plugin？/你用过哪些Plugin？他们是解决什么问题的？

- define-plugin：定义环境变量
- commons-chunk-plugin：提取公共代码
- uglifyjs-webpack-plugin：通过`UglifyES`压缩`ES6`代码

```
chunk是什么东西：webpack将多个模块打包之后的代码集合称为chunk。
```

>- 什么是chunk
>- 什么是commons-chunk-plugin

#### 什么是commons-chunk-plugin

commons-chunk-plugin是用来提取不同chunk的公共代码。webpack打包的代码都是以chunk的形式存储的。但是呢，不同chunk里可能存在相同的模块，CommonsChunkplugin，就是把这些不同chunk里重复的模块提取出来放到一个公共chunk里。这个公共chunk只需要下载一次，就可以让所有的chunk都使用了。而且这部分代码可以放到缓存里，这样以后就不用再下载了。

#### Loader和Plugin的不同？

`Loader` 就是加载器，他的本质是一个函数，Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。 因为webpack原生是只能解析js文件， Loader 充当翻译官的身份，对其他类型的资源进行转译工作。

`Plugin` 就是插件，它可以扩展webpack的功能，让webpack具有更多的灵活性。在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。

`Loader` 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 文件类型test、加载器类型loader、参数options 等属性。

`Plugin` 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。

#### 如果项目打包上线了，如何让用户知道文件更新了，而不使用缓存？

这个只需要在每次发布新版本时，给文件名添加hash名就可以了，对应的webpack配置就是将output的filename属性配置成[name].[contexthash:8].js就可以了

```
name、hash都是变量，所以放在[]里
```

#### 怎么实现在项目中使用强缓存，协商缓存

#### 今后打算怎么深入学习前端？

想深入学习Vue的源码，然后再学习它们周边的生态的源码，然后结合着更多的项目经验去更加深入的学习前端工程化。

深入学习JavaScript，看《JavaScript高级程序设计》这本书。

#### 如果用户出现打开网站后出现白屏，该如何排查问题

出现白屏也分成两种情况，一是一直白屏，而是短暂白屏。

一直白屏，那可能就是代码出现了错误，打开F12看看是否报错，如果有则按照报错信息去解决。

如果是短暂白屏，那就是加载性能问起。那么打开F12，查看NetWork，看瀑布图，是哪些文件加载时间过久。我们针对这些文件进行一些处理，比如说CDN外部加载、压缩等等。

#### 介绍一下事件冒泡和捕获

**事件冒泡**是指，事件会从最内层的元素开始发生，一直向上传播，直到document对象。

而**事件捕获**与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素。

在进行项目开发的时候，我们可以自行选择事件处理函数在哪一个阶段被调用。addEventListener方法用来素绑定事件处理的函数，它的第三个参数允许我们设置为捕获阶段或冒泡阶段触发。

**事件冒泡和事件捕获过程图：**

![image-20210406141845729](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141845729.png)

1-5是捕获过程，5-6是目标阶段，6-10是冒泡阶段；

#### 事件代理/委托

事件代理是将事件监听函数加到父元素上，借助事件冒泡机制来处理数目不定的子元素相同事件的方式。因为在事件冒泡中，子元素的事件触发会冒泡到父元素中，触发父元素相同的事件。若需要给多个子元素添加事件监听，我们只需给父元素添加事件监听即可。

如果我们不使用事件代理，那需要遍历父元素下的子元素，挨个进行事件监听。当元素量很大的时候，会影响页面性能。

```
事件流：事件发生顺序
```

#### 事件代理/委托有什么作用，主要用于哪些场景

事件代理的主要用处：

1.可以将多个事件处理函数减为一个，并且对于不同的元素可以有不同的处理方法。我们不必循环给每一个元素绑定事件，只需给父元素添加事件监听即可。

应用场景：

- 当要给一组子元素添加相同事件时，可以直接添加给父元素。

最经典的应用就是，一个列表会不断有新的数据的添加，如果每添加一个数据就生成一个li，就需要添加一个新的监听，代码结构就特别不好，这时候使用事件代理就很方便。

具体的例子，就比如，很多商品放在一个ul下面的li标签里面，里面有添加、删除、修改商品按钮，这时候我们就可以绑定这些商品的父元素ul标签，通过事件代理去找到要点击的商品，进行不同的函数处理。

>- 如何对于不同的元素可以有不同的处理方法

#### 如何对于不同的元素可以有不同的处理方法

通过判断event.target.nodeName来检查元素类型，根据元素类型执行不同的代码，即可实现不同的处理。

#### 阻止事件冒泡

- 给子级加 event.stopPropagation( )

- 在事件处理函数中返回 false

#### 阻止默认事件

- event.preventDefault( )

- return false

#### js怎么实现继承

**一、原型链继承**

将父类的实例作为子类的原型，这样根据原型链，子类就可以访问到父类的属性和方法。

```js
function Parent() {
   this.isShow = true
   this.info = {
       name: "yhd",
       age: 18,
   };
}

Parent.prototype.getInfo = function() {
   console.log(this.info);
   console.log(this.isShow); // true
}

function Child() {};
Child.prototype = new Parent();

let Child1 = new Child();
Child1.info.gender = "男";
Child1.getInfo();  // {name: "yhd", age: 18, gender: "男"}

let child2 = new Child();
child2.getInfo();  // {name: "yhd", age: 18, gender: "男"}
child2.isShow = false

console.log(child2.isShow); // false

```

**优点：**

> 1、父类方法可以复用

**缺点：**

> 1. 父类的所有`引用属性`（info）会被所有子类共享，更改一个子类的引用属性，其他子类也会受影响
> 2. 子类型实例不能给父类型构造函数传参

**二、构造函数继承**

 通过使用`call()`或`apply()`方法，`Parent`构造函数在为`Child`的实例创建的新对象的上下文执行了，就相当于新的`Child`实例对象上运行了`Parent()`函数中的所有初始化代码，结果就是每个实例都有自己的`info`属性。

```js
function Parent() {
  this.info = {
    name: "yhd",
    age: 19,
  }
}

function Child() {
    Parent.call(this)
}

let child1 = new Child();
child1.info.gender = "男";
console.log(child1.info); // {name: "yhd", age: 19, gender: "男"};

let child2 = new Child();
console.log(child2.info); // {name: "yhd", age: 19}

```

相比于原型链继承，构造函数继承可以给父类构造函数传参。

```js
function Parent(name) {
    this.info = { name: name };
}
function Child(name) {
    //继承自Parent，并传参
    Parent.call(this, name);
    
     //实例属性
    this.age = 18
}

let child1 = new Child("yhd");
console.log(child1.info.name); // "yhd"
console.log(child1.age); // 18

let child2 = new Child("wxb");
console.log(child2.info.name); // "wxb"
console.log(child2.age); // 18

```

**优点:**

> 1. 可以在子类构造函数中向父类传参数
> 2. 父类的引用属性不会被共享

**缺点：**

> 1. 子类不能访问父类原型上的方法（即不能访问Parent.prototype上定义的方法），因此所有方法属性都写在构造函数中，每次创建实例都会初始化

**三、组合继承**

组合继承综合了原型链继承和构造函数继承，将两者的优点结合了起来。

基本的思路就是使用原型链继承原型上的属性和方法，而通过构造函数继承实例属性，这样既可以把方法定义在原型上以实现重用，又可以让每个实例都有自己的属性

```javascript
function Parent(name) {
   this.name = name
   this.colors = ["red", "blue", "yellow"]
}
Parent.prototype.sayName = function () {
   console.log(this.name);
}

function Child(name, age) {
   // 继承父类属性
   Parent.call(this, name)
   this.age = age;
}
// 继承父类方法
Child.prototype = new Parent();

Child.prototype.sayAge = function () {
   console.log(this.age);
}

let child1 = new Child("yhd", 19);
child1.colors.push("pink");
console.log(child1.colors); // ["red", "blue", "yellow", "pink"]
child1.sayAge(); // 19
child1.sayName(); // "yhd"

let child2 = new Child("wxb", 30);
console.log(child2.colors);  // ["red", "blue", "yellow"]
child2.sayAge(); // 30
child2.sayName(); // "wxb"

复制代码
```

​     **优点：**

> 1. 父类的方法可以复用
> 2. 可以在Child构造函数中向Parent构造函数中传参
> 3. 父类构造函数中的引用属性不会被共享

#### CSS3新特性

1、过渡 transition 和 transform。主要是用来实现一些交互效果， 不会显得那么生硬。

```js
transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)
```

常用的transform：translate、translateX 、translateY、scale、scaleX、scaleY、rotate。

2、动画 animation , 主要是做一个预设的动画。

**语法：**

```js
animation：动画名称，一个周期花费时间，运动曲线（默认ease），动画延迟（默认0），播放次数（默认1），是否反向播放动画（默认normal），是否暂停动画（默认running）
```

| 值                        | 说明                             |
| :------------------------ | :------------------------------- |
| animation-name            | 指定要绑定到选择器的关键帧的名称 |
| animation-duration        | 动画指定需要多少秒完成           |
| animation-timing-function | 运动曲线                         |
| animation-delay           | 设置动画在启动前的延迟间隔。     |
| animation-iteration-count | 定义动画的播放次数。             |
| animation-direction       | 指定是否应该轮流反向播放动画。   |

**infinite：无数次**

3、形状转换 transform 用于2D或3D转换的元素

4、阴影

```
box-shadow: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认是从里往外，设置inset就是从外往里）;
```

| 值         | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| *h-shadow* | 必需的。水平阴影的位置。允许负值                             |
| *v-shadow* | 必需的。垂直阴影的位置。允许负值                             |
| *blur*     | 可选。模糊距离                                               |
| *spread*   | 可选。阴影的大小                                             |
| *color*    | 可选。阴影的颜色。在[CSS颜色值](https://www.runoob.com/cssref/css_colors_legal.aspx)寻找颜色值的完整列表 |
| inset      | 可选。从外层的阴影（开始时）改变阴影内侧阴影                 |

#### 有没有遇到过兼容性问题？如何解决的

1、不同浏览器默认margin，padding不同。
**解决办法**：
`*{margin:0;padding:0;}`

2、CSS书写样式的兼容性问题 
    平常在书写样式表时，若要使用CSS 3中的各种特效，都需要加上各种前缀让不同的浏览器得以支持，如实现一个圆角效果代码如下

```
boder-radius:3px;           /*圆角，水平半径为3px*/
-moz-border-radius:3-x;     /*Firefox浏览器*/
-webkit-boder-radius:3px;   /*WebKit核心浏览器*/
-o-border-radius:3px;       /*Opera浏览器*/
```

3、图片默认有间距

几个img标签放在一起的时候，有些浏览器会有默认的间距。

使用float属性为img布局。因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。

#### 对JavaScript的了解

#### JavaScript和c和c++和Java你觉得有什么区别？

#### 怎么理解面向对象？

#### this指向问题

this 永远指向最后调用它的那个对象，比如说

**1、对象调用，this 指向该对象（前边谁调用 this 就指向谁）。**

**2、直接调用的函数，this 指向的是全局 window 对象。**

**3、通过 new 的方式，this 永远被绑定在新创建的对象上，任何方式都改变不了 this 的指向。**

**4、箭头函数的This**

#### 什么是vuex

Vuex 是 Vue.js 的状态管理插件。它采用集中式存储管理应用的所有组件的状态，而更改状态的唯一方法是提交mutation。

#### 什么是状态管理模式？

可以简单的看成多个组件共享变量存储在一个对象中

#### 如何使用Vuex?

#### Vuex的五大核心

#### Vuex解决了什么问题？

解决两个问题

- 多个组件依赖于同一状态时，对于多层嵌套的组件的传参将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。
- 来自不同组件的行为需要变更同一状态。以往采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致无法维护的代码。

#### 什么时候用Vuex？/Vuex的应用场景

- 多个组件需要使用同一状态时。
- 来自不同组件的行为需要变更同一状态。

#### Vuex中要从state派生一些状态出来，且多个组件使用它，该怎么做，？

使用getter属性，相当Vue中的计算属性computed，只有原状态改变派生状态才会改变。

getter接收两个参数，第一个是state，第二个是getters(可以用来访问其他getter)。

然后在组件中可以用计算属性computed通过`this.$store.getters.total`这样来访问这些派生转态。

#### Vuex中action通常是异步的，那么如何知道action什么时候结束呢？

在action函数中返回Promise，然后再提交时候用then处理

```js
 changeInfo(context, payload) {
    return new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log(context);

        context.commit('changename');
        console.log(payload);
        resolve('我处理完啦~')
      }, 1000);
    })
  }
```

```js
change() {
    // this.$store.dispatch("changeInfo", "我是payload");
    this.$store.dispatch("changeInfo", "我是payload").then(v => {
        console.log("你输出的内容：" + v);
        console.log("我收到啦，谢谢~");
    });
},
```

#### 有用过Vuex模块吗，为什么要使用，怎么使用。

有，因为使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。所以将 store 分割成模块（module）。每个模块拥有自己的 state、mutations、actions、getters，甚至是嵌套子模块，从上至下进行同样方式的分割。

**具体的使用方法：**

1、新建一个mudule文件夹，创建一个moduleA.js，在这个js文件中export一个对象，其中包含了自己的 state、mutations、actions、getters和modules。

2、在index.js中引入该模块，并写入modules中

#### 在模块中，getter和mutation和action中怎么访问全局的state和getter？

在getter中可以通过第三个参数rootState访问到全局的state,可以通过第四个参数rootGetters访问到全局的getter。

在mutation中不可以访问全局的state和getter，只能访问到局部的state。

在action中第一个参数context中的`context.rootState`访问到全局的state，`context.rootGetters`访问到全局的getter。

#### 在组件中怎么访问Vuex模块中的getter和state,怎么提交mutation和action？

- 直接通过`this.$store.getters.getter方法名`和`this.$store.state.模块名.状态`来访问模块中的getter和state。

- 使用mutation，直接commit
- 使用action，直接dispatch。

#### 用过Vuex模块的命名空间吗？为什么使用，怎么使用。

用过，默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局命名空间**的——这样使得多个模块能够对同一 mutation 或 action 作出响应。

如果希望模块具有更高的封装度和复用性，你可以通过添加 `namespaced: true` 的方式使其成为带命名空间的模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。

#### 怎么在带命名空间的模块内提交全局的mutation和action？

若需要在全局命名空间内分发 action 或提交 mutation，将 `{ root: true }` 对象作为第三参数传给 `dispatch` 或 `commit` 即可。

```js
this.$store.dispatch('actionA', null, { root: true })
this.$store.commit('mutationA', null, { root: true })
```

#### 怎么在带命名空间的模块内注册全局的action？

若需要在带命名空间的模块注册全局 action，你可添加 `root: true`，并将这个 action 的定义放在函数 `handler` 中。例如：

```js
{
  actions: {
    someOtherAction ({dispatch}) {
      dispatch('someAction')
    }
  },
  modules: {
    foo: {
      namespaced: true,

      actions: {
        someAction: {
          root: true,
          handler (namespacedContext, payload) { ... } // -> 'someAction'
        }
      }
    }
  }
}
```

#### 组件中怎么提交modules中的带命名空间的moduleA中的mutationA？

在commit事件字符串中带模块名/

同理在dispatch事件字符串中带模块名/

```js
this.$store.commit("modulec/change");
this.$store.dispatch("modulec/actiontext");
```



#### 知道哪些设计模式？具体的使用场景？

单例模式、发布-订阅模式、观察者模式

**单例模式**

保证一个类仅有一个实例，并提供一个访问它的全局访问点，一般登录、购物车等都是一个单例。

应用场景：一个单一的对象，例如JQuery中的$、Vuex中的Store

```js
// 单例对象
class SingleObject {
    login () {}
}
// 访问方法
SingleObject.getInstance = (function () {
    let instance;
    return function () {
        if (!instance) {
            instance = new SingleObject();
        }
        return instance;
    }
})()
const obj1 = SingleObject.getInstance();
const obj2 = SingleObject.getInstance();
console.log(obj1 === obj2); // true
```

**观察者模式**

定义对象间的一种一对多的依赖关系，一个对象（Subject）维持一系列依赖于它的Observer对象，当有关状态发生变更时这个对象则通知一系列 Observer 对象进行更新。

#### 

应用场景：JS事件、Vue watch等

**发布-订阅模式**

发布订阅模式指的是希望接收通知的对象基于一个主题通过自定义事件订阅主题，发布事件的对象通过发布主题事件的方式通知各个订阅该主题的 Subscriber 对象。

**观察者模式 VS 发布订阅模式**

观察者模式与发布订阅模式都是定义了一个一对多的依赖关系，当有关状态发生变更时则执行相应的更新。

不同的是，在观察者模式中依赖于 Subject 对象的一系列 Observer 对象在被通知之后只能执行同一个特定的更新方法，而在发布订阅模式中则可以基于不同的主题去执行不同的自定义事件。相对而言，发布订阅模式比观察者模式要更加灵活多变。

#### HTTP协议

#### HTTP状态码

HTTP状态码表示客户端HTTP请求的返回结果

200：请求成功

301：永久性重定向，表示资源已被分配了新的 URL

403：对请求资源的访问被服务器拒绝

404：没有找到请求的资源

#### 如何提高网站的安全性？

1、使用HTTPS协议
以前网站采用的是http传输协议，这种传输协议简单，但是是通过明文传输，被截获后很容易将信息泄露。而https中，数据通过加密传输，黑客即使攻击了网站，得到的也是加了密的信息。

2、选择安全稳定的服务器

大厂的能够提供高防的防火墙和硬件设施

#### 深拷贝和浅拷贝

深拷贝是将一个对象从内存中完整的拷贝一份出来，开辟一个新的内存空间存放新对象，且**修改新对象不会影响原对象**。

浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以**如果其中一个对象改变了这个地址，就会影响到另一个对象**。

#### 浅拷贝的实现方式

**1.Object.assign()**

Object.assign() 方法可以把源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。

```js
let obj1 = { person: {name: "kobe", age: 41},sports:'basketball' };
let obj2 = Object.assign({}, obj1);
obj2.person.name = "wade";
obj2.sports = 'football'
console.log(obj1); // { person: { name: 'wade', age: 41 }, sports: 'basketball' }
```

2、展开运算符...

```js
let obj1 = { name: 'Kobe', address:{x:100,y:100}}
let obj2= {... obj1}
obj1.address.x = 200;
obj1.name = 'wade'
console.log('obj2',obj2) // obj2 { name: 'Kobe', address: { x: 200, y: 100 } }

```

3、Array.prototype.concat()

4、Array.prototype.slice()

5、函数库lodash的_.clone方法

#### 深拷贝的实现方式

1、函数库lodash的_.cloneDeep方法

### 快手真题

#### WeakMap和Map的区别，及其应用场景

`Map` 以键值对的形式存储数据, Map 对象的键可以是任何类型。Map可枚举

WeakMap 对象是一组键值对的集合，其中的键只能是弱引用对象。WeakMap不能枚举。

Map的应用场景：键找值，查看某数据是否已存在。数组去重。

WeakMap应用场景：通过 WeakMap 缓存计算结果

#### WeakSet和Set的区别，及其应用场景

WeakSet 对象允许你将弱引用对象储存在一个集合中

WeakSet 与 Set 的区别：

- WeakSet 的成员只能是对象，而不能是其他类型的值。而 Set 对象都可以。
- 其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。
- 因为垃圾回收机制何时运行是不可预测的，ES6 规定WeakSet 对象是无法被遍历的。

```js
WeakSet 没有size属性，没有办法遍历它的成员。
```

根据WeakSet的特点，它的应用场景，

1、WeakSet 可以用来保存 DOM 节点，不用担心这些节点从文档移除时会引发内存泄露。因为WeakSet 里面的引用，都不计入垃圾回收机制，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中，就不会造成内存泄漏。

Set 的应用场景：数组去重

#### Map与Set的区别

Set 叫做集合，Map 叫做字典。

Set类似于数组，但成员是唯一且无序的，没有重复的值。我们可以使用new Set来创建一个Set。

```
1、操作方法:
add(value)：新增
delete(value)：存在即删除集合中value
has(value)：判断集合中是否存在 value
has(value)：判断集合中是否存在 value

set.size获取个数

2、Set转数组
Array.from 方法可以将 Set 结构转为数组
或者使用...剩余运算符
```

Map类似于对象，以键值对的形式进行存储，与对象不同的是，Map的键可以为任意类型，而对象的键局限于字符串。我们可以使用new Map来创建一个Map。

```
1、操作方法
set(key, value)：向字典中添加新元素
get(key)：通过键查找特定的数值并返回
has(key)：判断字典中是否存在键key
delete(key)：通过键 key 从字典中移除对应的数据
clear()：将这个字典中的所有元素删除
```

#### 浏览器垃圾回收机制说一下

JS的垃圾回收机制是，垃圾收集器会定期找出那些不再继续使用的变量，然后释放其内存。

垃圾回收实现方式主要有两种，**标记清除**和**引用计数**。

**标记清除：**

垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记；然后，它会去掉环境中的变量以及被引用的变量，在此之后再被加上标记的变量将被视为准备删除的变量，这时候垃圾回收器就销毁那些带标记的值并回收它们所占用的内存空间。

**引用计数：**

引用计数是指每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。当这个值的引用次数变成0时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾回收器下次再运行时，它就会释放那些引用次数为0的值所占用的内存。

#### 数组扁平化

数组扁平化：将嵌套多层的数组进行降维处理。

可以使用数组拍平方法 `Array.prototype.flat()`

- `Array.prototype.flat()` 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。

- 不传参数时，默认“拉平”一层，可以传入一个整数，表示想要“拉平”的层数。

- 传入 `<=0` 的整数将返回原数组，不“拉平”

- `Infinity` 关键字作为参数时，无论多少层嵌套，都会转为一维数组

- 如果原数组有空位，`Array.prototype.flat()` 会跳过空位。

#### 实现数组拍平flat函数

flat函数就是在数组中找到是数组类型的元素，然后将他们展开。

**函数实现步骤：**

1、遍历数组的每一个元素；

2、判断元素是否是数组；

3、将数组的元素展开一层；

```js
// forEach + 递归
Array.prototype.myflat = function (num = 1) {
  //遍历数组
  //判断元素是否为数组
  //展开
  //num =0 返回
  if (Number(num) <= 0) {
    return this;
  }
  let arr = [];
  this.forEach(item => {
    if (Array.isArray(item)) {
      arr = arr.concat(item.myflat(num - 1));
    } else {
      arr.push(item);
    }
  })
  num--;
  return arr;
}
```

#### 用 reduce 去实现 flat函数

```
reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
```

```js
const arr = [1, 2, 3, 4, [1, 2, 3, [1, 2, 3, [1, 2, 3]]], 5, "string", { name: "弹铁蛋同学" }]

// 首先使用 reduce 展开一层
arr.reduce((pre, cur) => pre.concat(cur), []);
// [1, 2, 3, 4, 1, 2, 3, [1, 2, 3, [1, 2, 3]], 5, "string", { name: "弹铁蛋同学" }];

// 用 reduce 展开一层 + 递归
const flat = arr => {
  return arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) ? flat(cur) : cur);
  }, []);
};
// [1, 2, 3, 4, 1, 2, 3, 1, 2, 3, 1, 2, 3, 5, "string", { name: "弹铁蛋同学" }];

```

`flat` 函数执行是会跳过空位的

```js
// reduce + 递归
Array.prototype.myflat = function (num = 1) {
  //遍历数组
  //判断元素是否为数组
  //展开
  //num =0 返回
  if (Number(num) <= 0) {
    return this;
  }
  let arr = [];
  arr = this.reduce((pre, cur) => {
    if (Array.isArray(cur)) {
      pre = pre.concat(cur.myflat(num - 1));
    } else {
      pre.push(cur);
    }
    return pre;
  }, [])
  num--;
  return arr;
}
```

#### hististory 路由和 hash 路由的区别, 在浏览器有什么影响

URL的hash就是锚点（#），本质上是改变window.locatin的href

history接口有五种模式改变url

#### 介绍一下遍历方法

- `for...of`
- `for...in`
- `forEach()`
- `reduce()`
- `map()`

### 1.地址栏中输入网址后发生了什么

```
1.URL解析
2.缓存查找
3.DNS解析
4.TCP连接，三次握手
5.http请求
6.服务器响应，浏览器解析。
7.浏览器渲染
8.TCP连接断开，4次挥手
```

从用户输入一个网址到网页最终展现，中间的大致流程如下：

（1）首先浏览器会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果URL的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。

（2）浏览器会进行缓存查找。判断请求资源是否在缓存里，如果请在并且没有失效，那么就直接使用，否则向服务器发起新的请求。

（3）进行DNS解析，获取URL中域名的 IP 地址。首先会查找浏览器缓存，如果有该域名的 IP 地址的缓存，如果有则使用，如果没有，会检查检查操作系统缓存，常见的如hosts文件。如果没有，则会查看本地DNS是否有该域名的 IP 地址的缓存，如果没有，**本地 DNS 服务器**向**根域名服务器**发起请求，获得负责的顶级域名服务器的地址后，再向**顶级域名服务器**请求，然后获得负责的权威域名服务器的地址后，再向**权威域名服务器**发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地DNS服务器发起请求属于递归请求（本地服务器会帮主机进行DNS查询，这一步对主机是透明的。因此是属于递归），本地DNS服务器向各级域名服务器发起请求属于迭代请求。（迭代的查询IP）

![image-20210406141758418](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141758418.png)

![image-20210406142241869](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406142241869.png)

（4）我们通过DNS解析获取到IP地址后， 需要发起TCP连接请求。 TCP 建立连接需要经历三次握手的过程，首先客户端向服务器发送一个 **SYN 连接请求报文段**和一个随机序号，服务端接收到请求后向客户端发送一个 **SYN ACK报文段**和一个随机序号并且ACK序列号为客户端序列号+1，确认连接请求。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个 **ACK 确认报文段**，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。

```
在TCP报文的报头中，有几个标志字段：
1、 SYN：同步连接序号Synchronize Sequence Numbers，TCP SYN报文就是把这个标志设置为1，来请求建立连接；
2、 ACK：请求/应答状态Acknowledgement。0为请求，1为应答；
3、 FIN：结束连线。如果FIN为0是结束连线请求，FIN为1表示结束连线；
```



![image-20210406142252342](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406142252342.png)

（5）握手成功后， 浏览器就可以向服务器发送**http**请求了。 **发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)**。HTTP请求报文是由三部分组成: 请求行,请求报头和请求正文。

（6）服务器端会监听浏览器端发送的http请求，当浏览器的请求发出后，服务端就会接受该请求，并对相应的信息进行处理，将处理的结果响应给浏览器端。浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。

（7）浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局，计算每个节点的几何位置。布局完成后，进入绘制阶段，将各个节点绘制到屏幕上。这个时候整个页面就显示出来了。

（8）最后一步是 断开 TCP连接，需要经历四次挥手过程。

4次挥手大体的过程如下：

1. 客户端向服务器发送一个**FIN连接释放报文段**和一个随机序号，通知服务器现在需要断开（第一次挥手）
2. 服务器接到要断开的请求之后，向客户端发送一个**ACK确认报文段**和一个随机序号，服务端进入**CLOSE_WAIT**（关闭等待）状态（第二次挥手）
3. 如果服务端也想断开连接了，向客户端发送一个**FIN连接释放报文段**和一个随机序号（第三次挥手）
4. 客户端接收到服务器消息后，向服务器端发送一个**ACK确认报文段**和一个随机序号，服务器收到消息后，就处于关闭连接了，处于 **CLOSED** 状态（第四次挥手）

![image-20210406142306382](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406142306382.png)



参考资料：

[通俗易懂了解TCP三次握手](https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&mid=2665513094&idx=1&sn=a2accfc41107ac08d74ec3317995955e&scene=21#wechat_redirect)

[三次握手和四次挥手](https://juejin.cn/post/6844903958624878606#heading-0)

[如何向学妹解释在地址栏中输入网址后发生了什么？](https://juejin.cn/post/6844903806505844749#heading-6)

**扩展问题**

```
Q:说一说三次握手
三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

Q:为什么需要三次握手，两次不行吗？
弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

第一次握手：客户端发送网络包，服务端收到了。
这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
第二次握手：服务端发包，客户端收到了。
这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
第三次握手：客户端发包，服务端收到了。
这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。

因此，需要三次握手才能确认双方的接收与发送能力是否正常。


Q:挥手为什么要4次？
关闭连接时，当服务端收到FIN报文时，可能并不会立即关闭，所以只能先回复一个ACK报文，告诉客户端，"你发的FIN报文我收到了"。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此ACK和FIN不能一起发送。故需要四次挥手。
```

#### map和foreach有什么区别

map和foreach都可以用来遍历数组。

`forEach()`: 针对每一个元素执行提供的函数

`map()`: 创建一个新的数组，其中每一个元素由调用数组中的每一个元素执行提供的函数得来。

map和foreach的主要区别：

1、forEach()`方法不会返回执行结果，而是`undefined；`map()`方法会得到一个新的数组并返回。

2、map能保证原始数组的不变。forEach 不能确保数组的不变性，只有你不改变数据，原数组才会不变。

选择使用哪个，如果不打算改变数据，只想获取推荐使用foreach；`map()`适用于你要改变数据值的时候

#### 手写：Promise.all()/race()

#### 盒模型

盒模型分为IE盒模型和W3C标准盒模型。盒模型都是由四个部分组成的，分别是content、padding、margin和border。

标准盒模型和IE盒模型的区别在于设置width和height时，包含内容不同。标准盒模型的width和height属性只包含了content，而IE盒模型的width和height属性包含了border、padding和content。

在ie8+浏览器中，我们可以通过修改元素的box-sizing属性来改变元素的盒模型。

#### 说一下浏览器缓存

当浏览器请求一个网站的时候，会加载各种各样的资源，比如HTML CSS和JS等等。对于一些静态资源，浏览器就会把他们保存在本地文件中，下次访问的时候直接加载这些资源，加速访问。

浏览器是否使用缓存、缓存的有效期，是由服务器控制，服务器发回的响应的「响应头」部分的某些字段指明了有关缓存的关键信息，比如Cache-Control(控制缓存的行为)等等。

这个就是浏览器缓存的一个概念。

#### 浏览器缓存机制

浏览器中缓存可分为强缓存和协商缓存。强缓存的话，它不会向服务器发送请求，而是直接从内存中读取资源。协商缓存，他是会向服务器发送请求，服务器会根据这个请求上面的参数来判断是否命中协商缓存，如果命中协商缓存，就返回304状态码通知浏览器从缓存中读取资源。

浏览器使用缓存资源有以下几个过程：

1）浏览器在加载资源时，先根据这个资源的一些header判断它是否命中强缓存，**强缓存如果命中，浏览器直接从自己的缓存中读取资源，不会发请求到服务器**。

2）当强缓存没有命中的时候，浏览器发送一个请求到服务器，**验证这个资源是否命中协商缓存**。如果协商缓存命中，服务器会将这个请求返回，**但是不会返回这个资源的数据，而是告诉客户端可以直接从缓存中加载这个资源**。

3）当协商缓存也没有命中的时候，浏览器直接从服务器加载资源数据。

```
简写：
当浏览器再次访问一个已经访问过的资源时，它会这样做：
1.看看是否命中强缓存，如果命中，就直接使用缓存了。
2.如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存。
3.如果命中协商缓存，服务器会返回 304 告诉浏览器使用本地缓存。
4.否则，返回最新的资源。
```

>- 强缓存是如何实现的
>- 协商缓存是如何实现的

#### 强缓存是如何实现的

强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。

Expires是HTTP 1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示。

Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示。

>- Exipires缓存原理
>- Cache-Control缓存原理
>- Exipres 和CacheControl的区别

#### Exipires的缓存原理：

1、浏览器第一次跟服务器请求资源，服务器在返回这个资源的同时，在response的header加上Expires的header。

![image-20210406141736081](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141736081.png)

2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来。

3、浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，拿出它的Expires跟当前的请求时间比较**，如果请求时间在Expires指定的时间之前，就能命中缓存，否则就不行；

4、如果缓存没有命中，浏览器直接从服务器加载资源时，Expires Header在重新加载的时候会被更新。

#### CacheControl的缓存原理

1、浏览器第一次跟服务器请求资源，服务器在返回这个资源的同时，在response的header加上Cache-Control的header

![image-20210406141721736](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141721736.png)

2、浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来。

3、浏览器再请求这个资源时，**先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期**，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。

4、如果缓存没有命中，浏览器直接从服务器加载资源时，**Cache-Control Header在重新加载的时候会被更新**；

这两个header可以只启用一个，也可以同时启用，**当response header中，Expires和Cache-Control同时存在时，Cache-Control优先级高于Expires**：

>- HTTP状态码

#### 协商缓存

当浏览器对某个资源的请求没有命中强缓存，**就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串**。

**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的**。

**【Last-Modified，If-Modified-Since】的控制缓存的原理：**

1、浏览器第一次跟服务器请求资源，服务器在返回这个资源的同时，**在response的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间**。

2、浏览器再次跟服务器请求这个资源时，**会在request的header上加上If-Modified-Since的header**，这个header的值就是上一次请求时返回的Last-Modified的值：

3、服务器再次收到资源请求时，**根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化**，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。

4、浏览器收到304的响应后，就会从缓存中加载资源。

5、如果协商缓存没有命中，浏览器直接从服务器加载资源时。

```
一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是有时候也会服务器上资源其实有变化，但是最后修改时间却没有变化的情况，而这种问题又很不容易被定位出来，而当这种情况出现的时候，就会影响协商缓存的可靠性
```



**【ETag、If-None-Match】缓存原理：**

1、浏览器第一次跟服务器请求一个资源，**服务器在返回这个资源的同时，在response的header加上ETag的header**，这个header是服务器根据当前请求的资源生成的一个唯一标识，**这个唯一标识是一个字符串，只要资源有变化这个串就不同**。

![image-20210406141653228](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141653228.png)

2、浏览器再次跟服务器请求这个资源时，**在request的header上加上If-None-Match的header**，这个header的值就是上一次请求时返回的ETag的值。

![image-20210406141643499](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141643499.png)

3、服务器再次收到资源请求时，**根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag**，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。

4、浏览器收到304的响应后，就会从缓存中加载资源。

>- Etag和Last-Modified的区别
>- 强缓存和协商缓存的区别

#### Exipres 和CacheControl的区别

Expires是较老的强缓存管理header，**由于它是服务器返回的一个绝对时间**，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题，**比如：随意修改下客户端时间，就能影响缓存命中的结果**。

Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示，更安全一些

#### Etag和Last-Modified的区别

ETag相对于Last-Modified可以更加准确的判断文件内容是否被修改

#### 强缓存和协商缓存的区别

强缓存：直接从本地副本对比读取，**不去请求服务器**，返回的状态码是**200**

协商缓存：会去服务器比对，若没改变才直接读取本地缓存，返回的状态码是**304**

强缓存与协商缓存的共同点是：**如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据**；区别是：**强缓存不发请求到服务器，协商缓存会发请求到服务器**。

#### Git中，有代码不想要了，用什么命令

没有加入到缓存区（没有 git add)：git checkout -- file  用来放弃掉所有还没有加入到缓存区

已经 git add ：git reset HEAD filepathname

git commit 提交：git reset --hard HEAD^ 回退版本

#### 说说vue的好处

- 轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十kb；

- 比较好上手，易于理解和学习；

- 数据双向绑定：在数据操作方面更为简单；

- 组件化开发：实现了html的封装和重用，在构建单页面应用有很大的优势
- 虚拟DOM：dom操作是非常耗费性能的，不再使用原生的dom操作节点，极大解放dom操作，但具体操作的还是dom不过是换了另一种方式；

>- 说一下双向绑定的原理
>- 说一下组件化开发的思想
>- 说一下虚拟DOM

### 为什么vue组件中data必须是一个函数？

因为对象是引用类型，如果data是个对象，当复用组件时，所有组件都会指向这一个data对象，当在一个组件中修改data时，其他复用组件中的data会同时被修改。而使用返回对象的函数，由于每次返回的都是一个新对象（Object的实例），引用地址不同，则不会出现这个问题。

### vue中v-if和v-show有什么区别？

1、v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。

2、v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。

### computed和watch的区别

#### 计算属性computed：

- 支持缓存，只有依赖数据发生改变，才会重新进行计算
- 不支持异步，如果computed内有异步操作就会无效，无法监听数据的变化
- 一般用computed来计算依赖其他属性的属性，例如筛选数据等。
- 如果computed属性的属性值是函数，那么默认会走get方法；其实在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。
- 在html中使用时，直接写属性名，无序加括号。
- 计算属性的缓存是
- 基于data中声明过或者父组件传递的props中的数据通过计算得到的值

#### 侦听属性watch：

- 不支持缓存，数据变，直接会触发相应的操作；
- watch支持异步；
- watch监听的函数接收两个参数，第一个参数是最新的值；第二个参数是旧的值；
- 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数：
- watch 默认在组件加载时，不会立即触发回调函数执行。我们可以使用immediate: true 让它立即触发。
- watch 默认监听第一层数据，使用deep:true 可以一层层往下遍历，给对象的所有属性都加上这个监听器（但这样开销大，不建议）；如果想监听对象的某个属性，可以采用字符串形式监听。

```js
//一般watch使用：属性名 + 函数
watch: {
    // 监听firstName,如果firstName改变，则修改fullName
    firstName: function (val, old) {
        this.firstName = val;
        this.fullName = this.firstName + this.lastName
    }
}

//设置watch参数：属性名 +对象（handler处理函数，参数配置）
watch: {
    lastName: {
          handler(val, old) {
            this.lastName = val;
            console.log(val + ' ' + old);
            this.fullName = this.firstName + this.lastName
          },
          immediate: true
        }
}

//深入监听：对象的每个属性都会触发监听Handler
watch: {
    obj: {
        handler(val, old) {
            console.log("obj change");
        },
            deep: true
    }
}

//字符串形式监听：Vue.js才会一层一层解析下去，直到遇到属性name，然后才给name设置监听函数。
watch: {
    'obj.name': {
        handler(val, old) {
            console.log("obj change");
        },
    }
}
```

### vue-loader是什么？使用它的用途有哪些？

vue-loader是vue文件的一个加载器，向vue-loader输入一个vue文件内容，然后他会对vue文件中的template js style进行处理，输出一个js对象，这个对象主要包括render、components以及其他自己写的内容以及一些自动生成的钩子函数。

### vue中的$nextTick是什么？它的原理和作用是啥？

nextTick在官网的定义是在下次 DOM 更新循环结束之后执行的延迟回调，在修改数据之后立即使用该方法，获得更新后的DOM。

nextTick的源码我看了一些，怎么说呢。就是没有彻底了解，还得多看几遍。

**原理：**

这个nextTick它是跟异步更新DOM策略相关联的，先说Vue的异步更新策略，当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。当异步执行update的时候，会调用queueWatcher函数。

![image-20210406141625969](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141625969.png)

在这个queueWatcher函数中，Watch对象并不是立即更新视图，而是被push到一个队列中，处于waiting状态，多个Watch对象被push进这个队列中，等到下一个tick执行时，这些Watch对象才会被遍历取出，更新视图。在源码中，它是会对id重复的Watcher进行一个去重，id相同不会多次加入队列中。

>- 是怎么对Watcher去重的？
>
>  通过一个标记哈希表判断该id是否存在 has[id] ，存在就跳过

```js
 /*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/
export function queueWatcher (watcher: Watcher) {
  /*获取watcher的id*/
  const id = watcher.id
  /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/
  if (has[id] == null) {
    has[id] = true
    if (!flushing) {
      /*如果没有flush掉，直接push到队列中即可*/
      queue.push(watcher)
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      let i = queue.length - 1
      while (i >= 0 && queue[i].id > watcher.id) {
        i--
      }
      queue.splice(Math.max(i, index) + 1, 0, watcher)
    }
    // queue the flush
    if (!waiting) {
      waiting = true
      nextTick(flushSchedulerQueue)
    }
  }
}
```

![image-20210406141545837](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141545837.png)

nextTick的目的，就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。

nextTick实际上是将传进来的callback，push到callbacks数组中，并执行timerFunc。timerFunc是会根据当前环境有不同的实现，通过isNative判断某个函数是否为原生函数，它是按照Promise，MutationObserver，setImmediate，setTimeout优先级进行判断，哪个存在使用哪个。

因为Promise的then方法和MutationObserver都是会在微任务中执行，会比setTimeout早执行，所以优先使用，两种函数都不存在的环境下才会考虑setImmediate、setTimeout，在task推入这个函数。

>- 什么是timerFunc
>
>  timerFunc是会根据当前环境有不同的实现，通过isNative判断某个函数是否为原生函数，它是按照Promise，MutationObserver，setImmediate，setTimeout优先级进行判断，哪个存在使用哪个。
>
>  因为Promise的then方法和MutationObserver都是会在微任务中执行，会比setTimeout早执行，所以优先使用，两种函数都不存在的环境下才会考虑setImmediate、setTimeout，在task推入这个函数。
>
>- 为什么要优先使用microtask
>
>  根据 HTML标准，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。
>  反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。

```js
/**
 * Defer a task to execute it asynchronously.
 */
 /*
    延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function
    这个函数的作用是在task或者microtask中推入一个timerFunc，在当前调用栈执行完以后以此执行直到执行到timerFunc
    目的是延迟到当前调用栈执行完以后执行
*/
export const nextTick = (function () {
  /*存放异步执行的回调*/
  const callbacks = []
  /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/
  let pending = false
  /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/
  let timerFunc

  /*下一个tick时的回调*/
  function nextTickHandler () {
    /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/
    pending = false
    /*执行所有callback*/
    const copies = callbacks.slice(0)
    callbacks.length = 0
    for (let i = 0; i < copies.length; i++) {
      copies[i]()
    }
  }

  // the nextTick behavior leverages the microtask queue, which can be accessed
  // via either native Promise.then or MutationObserver.
  // MutationObserver has wider support, however it is seriously bugged in
  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It
  // completely stops working after triggering a few times... so, if native
  // Promise is available, we will use it:
  /* istanbul ignore if */

  /*
    这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法
    优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。
    如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。
    参考：https://www.zhihu.com/question/55364497
  */
  if (typeof Promise !== 'undefined' && isNative(Promise)) {
    /*使用Promise*/
    var p = Promise.resolve()
    var logError = err => { console.error(err) }
    timerFunc = () => {
      p.then(nextTickHandler).catch(logError)
      // in problematic UIWebViews, Promise.then doesn't completely break, but
      // it can get stuck in a weird state where callbacks are pushed into the
      // microtask queue but the queue isn't being flushed, until the browser
      // needs to do some other work, e.g. handle a timer. Therefore we can
      // "force" the microtask queue to be flushed by adding an empty timer.
      if (isIOS) setTimeout(noop)
    }
  } else if (typeof MutationObserver !== 'undefined' && (
    isNative(MutationObserver) ||
    // PhantomJS and iOS 7.x
    MutationObserver.toString() === '[object MutationObserverConstructor]'
  )) {
    // use MutationObserver where native Promise is not available,
    // e.g. PhantomJS IE11, iOS7, Android 4.4
    /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/
    var counter = 1
    var observer = new MutationObserver(nextTickHandler)
    var textNode = document.createTextNode(String(counter))
    observer.observe(textNode, {
      characterData: true
    })
    timerFunc = () => {
      counter = (counter + 1) % 2
      textNode.data = String(counter)
    }
  } else {
    // fallback to setTimeout
    /* istanbul ignore next */
    /*使用setTimeout将回调推入任务队列尾部*/
    timerFunc = () => {
      setTimeout(nextTickHandler, 0)
    }
  }

  /*
    推送到队列中下一个tick时执行
    cb 回调函数
    ctx 上下文
  */
  return function queueNextTick (cb?: Function, ctx?: Object) {
    let _resolve
    /*cb存到callbacks中*/
    callbacks.push(() => {
      if (cb) {
        try {
          cb.call(ctx)
        } catch (e) {
          handleError(e, ctx, 'nextTick')
        }
      } else if (_resolve) {
        _resolve(ctx)
      }
    })
    if (!pending) {
      pending = true
      timerFunc()
    }
    if (!cb && typeof Promise !== 'undefined') {
      return new Promise((resolve, reject) => {
        _resolve = resolve
      })
    }
  }
})()
```

**作用：**

在修改data中的数据后访问真实的DOM节点更新后的数据。

```html
<template>
  <div>
    <div ref="test">{{test}}</div>
    <button @click="handleClick">tet</button>
  </div>
</template>
```

```js
export default {
    data () {
        return {
            test: 'begin'
        };
    },
    methods () {
        handleClick () {
            this.test = 'end';
            this.$nextTick(() => {
                console.log(this.$refs.test.innerText);//打印"end"
            });
            console.log(this.$refs.test.innerText);//打印“begin”
        }
    }
}
```

#### 什么是进程，什么是线程

**进程：**是cpu分配资源的最小单位，是能拥有资源和独立运行的最小单位

**线程：**是cpu调度的最小单位，线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程

```
进程 就是一个公司，每个公司都有自己的资源可以调度；公司之间是相互独立的；而 线程 就是公司中的每个员工，多个员工一起合作，完成任务，公司可以有一名员工或多个，员工之间共享公司的空间。
```

**浏览器是多进程的：** 在浏览器中，每打开一个tab页面，其实就是新开了一个进程，在这个进程中，还有ui渲染线程，js引擎线程，http请求线程等。 所以，浏览器是一个多进程的。

**js是单线程的：** js是作为浏览器的脚本语言，主要是实现用户与浏览器的交互，以及操作dom；这决定了它只能是单线程，否则会带来很复杂的同步问题。 

举个例子：如果js被设计了多线程，如果有一个线程要修改一个dom元素，另一个线程要删除这个dom元素，此时浏览器就会一脸茫然，不知所措。所以，为了避免复杂性，从一诞生，JavaScript就是单线程。

#### v-for中key的作用

当Vue使用`v-for`更新已渲染的元素列表时,默认用`就地复用`策略、

为了给Vue一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，需要为每项提供一个唯一 key 属性。

key 的特殊属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes。如果不使用 key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试再利用相同类型元素的算法。使用key，它会基于key的变化重新排列元素顺序，并且会移除 key 不存在的元素。

>- 设计DOM
>- 虚拟DOM
>- diff原理

#### 组件通信

**父传子**

- 通过props传递，基本使用：

1. 在父组件上绑定一些attribute。 v-bind:xxx="..."
2. 在子组件中注册自定义attribute props:['xxx','yyy'....]，此时就变成了子组件的property
3. 在子组件中访问这些数据

- 通过$children拿到子组件数组

>- 知道单向数据流吗
>- 子组件向更改prop呢？

**子传父**

- 使用自定义事件监听子组件的事件，基本使用：

1. 父组件使用v-on:xxx="..."设置监听子组件的任意事件。
2. 子组件调用$emit('xxx',[抛出值])。
3. 父组件使用$event访问抛出值，并对事件进行处理。若事件处理函数为方法，抛出值作为第一个参数传入方法中。

- 通过$parent拿到父组件

**兄弟组件通信**

- vuex

- 中央通信 

  ```js
  let bus = new Vue();
  //A组件： 发布者
  methods:{
      say(){
          bus.$emit('事件名',数据)； //发送
      }
  }
  //B组件： 订阅者
  created(){
      bus.$on("A发送的事件名",函数) //接收
  }
  ```

#### prop 验证，和默认值

我们在父传子时，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告。

```js
 props: {
        // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
        propA: Number,
        // 多个可能的类型
        propB: [String, Number],
        // 必填的字符串
        propC: {
          type: String,
          required: true
        },
        // 带有默认值的数字
        propD: {
          type: Number,
          default: 100
        }
	}
}
```

#### 请说下封装 vue 组件的过程

组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发：效率低、难维护、复用性等问题。

组件封装的过程其实就是讲一个大页面拆分成多个小组件的过程，这些小组件可以在多个页面中进行复用。

>- Vue平时怎么划分组件

#### 请说下封装 vue 组件的过程

平时划分组件有几种思路：

1、页面上的功能块，select，pagenation,和一些需要大量代码去实现的一些部分，我们可以把它提取出来放到一起或者分类。

2、公共部分划分。

3、页面区域来划分,

#### 知道单向数据流吗

prop 只可以从上一级组件传递到下一级组件，就是所谓的单向数据流。

#### 子组件向更改prop呢？

- 将prop作为本地数据使用；建议：保存为本地data
- prop传入需转化;建议：使用计算属性

#### 什么是虚拟DOM

虚拟DOM是对真实DOM的一个抽象，其实就是用js对象来模拟dom结构。在Vue中，虚拟DOM是用一个VNode类来描述的，在这个类中有几个关键的属性：

- tag ： vnode的标签属性
- data：包含了真实DOM节点的class、attribute、style还有一些绑定的事件。
- children：vnode的子节点
- text：文本属性
- `elm` ：为这个`vnode`对应的真实`dom`节点
- key：vnode 的一个标记，可以提高diff效率

虚拟DOM的应用，主要是避免频繁操作DOM，它的实现思路是：

1、需要用JS对象模拟DOM树

2、比较两个虚拟DOM树的差异，使用diff算法

3、将两个虚拟DOM对象的差异应用到真正的DOM树上，使用patch。

>- 什么是回流和重绘，如何避免？
>- attribute和property的区别
>- diff算法

#### diff算法

diff 算法是用来比较新旧两棵虚拟DOM树的差异，找出差异并更新到真正的DOM树上。diff的过程就是调用名为`patch`的函数，通过比较新旧节点，一边比较一边给**真实的DOM**打补丁的过程。

当数据发生改变时，setter函数会通知Dep调用`Dep.notify`通知管理的Watcher对象，触发Watch对象的update，update又会调用`patch`给真实的DOM打补丁，更新相应的视图。

patch函数接收两个参数`oldVnode`和`Vnode`分别代表旧节点和新的节点。

- 在patch函数中判断两个节点是否值得比较，如果值得就执行patchVnode
- 如果不值得，就直接用新节点替换旧节点。

>- 如何判断值不值得：会判断key值、标签名以及data（data中包括class style等等），判断是不是一样的节点，如果是一样的节点，才值得深入检查子节点，如果说不一样，就直接替换。

patchVnode函数中，进行了几个判断：

- 判断`Vnode`和`oldVnode`是否指向同一个对象，如果是，那么直接`return`

- 如果他们都只有文本节点并且不相等，就会直接进行文本节点的替换。

- 如果`oldVnode`有子节点而`Vnode`没有，则删除elm真实DOM下的子节点

- 如果`oldVnode`没有子节点而`Vnode`有，则将`Vnode`的子节点添加到elm真实DOM结点中。

- 如果两者都有子节点，则执行`updateChildren`函数比较子节点。

![image-20210406141522822](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141522822.png)

**updateChildren**

![image-20210406141117834](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406141117834.png)

在这个方法中，有两个数组，分别是新旧虚拟DOM树的节点数组；有四个指针，分别指向旧节点数组和新节点数组的头和尾节点，会对这四个指针两两做sameVnode比较，一共有4种比较方式，如果有能匹配上，那么真实的DOM节点就会移动到Vnode相应的位置。

- 如果是oldS和newE匹配上了，那么真实dom中的第一个节点会移到oldEnd的后面
- 如果是oldE和S匹配上了，那么真实dom中的最后一个节点会移到oldStart前面。匹配上的两个指针向中间移动
- 如果四种匹配均未成功，则分成两种情况考虑：
  - 新旧节点存在key，则会根据OldChild的key生成一张hash表，用newStart的key与hash表做匹配：
  
    - 匹配成功，就判断是否为sameNode，是，则就将匹配上的节点在真实DOM中将其移到oldStartVnode的位置，并将被匹配到old中的节点置undefined；不是，则将insertBefore生成新的节点插入真实DOM。
  
    - 如果匹配不上，将生成newStart的节点插入到dom中对应的oldStart位置，S指针向中间移动。
  
  - 如果没有key,则直接将newStart生成新的节点插入真实DOM。

这个匹配过程的结束有两个条件：

- `oldS > oldE`表示`oldCh`先遍历完，那么就将多余的newVnode根据index添加到真实的dom中去
- `S > E`表示newVnode先遍历完，那么就在真实dom中将区间为`[oldS, oldE]`的多余节点删掉

```typescript
while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
    if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx] // Vnode has been moved left
    } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx]
    } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
    } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx)
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm))
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
    } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
    } else {
        if (isUndef(oldKeyToIdx)) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        idxInOld = isDef(newStartVnode.key)
            ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
        if (isUndef(idxInOld)) { // New element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
        } else {
            vnodeToMove = oldCh[idxInOld]
            if (sameVnode(vnodeToMove, newStartVnode)) {
                patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx)
                oldCh[idxInOld] = undefined
                canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm)
            } else {
                // same key but different element. treat as new element
                createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx)
            }
        }
        newStartVnode = newCh[++newStartIdx]
    }
}
if (oldStartIdx > oldEndIdx) {
    refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm
    addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)
} else if (newStartIdx > newEndIdx) {
    removeVnodes(oldCh, oldStartIdx, oldEndIdx)
}
```



>- diff算法的复杂度
>- diff算法移动的过程 （即updateChildren)

#### diff算法移动的过程 （说一下updateChildren方法）

diff算法的移动是在updateChildren里边，在这个方法中.....

#### diff算法的复杂度

diff算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较，算法复杂度就可以达到 `O(n)`。因为在前端当中，很少会跨越层级地移动 `DOM` 元素，所以 `Virtual DOM` 只会对同一个层级的元素进行对比。

#### 浏览器渲染过程

```
1.渲染的基本步骤
	构建Dom树。将包含三类东西，构建会被Js阻塞。
	构建CSSOM规则树。
	根据DOM CSSOM构建渲染树。渲染对象，不是一对一关系。
	根据渲染树布局，计算每个节点的几何信息。
	将各个节点绘制到屏幕上。
```

所有的浏览器渲染引擎工作流程大致分为5步：创建 `DOM` 树 —> 创建 `Style Rules` -> 构建 `Render` 树 —> 布局 `Layout` -—> 绘制 `Painting`。

- 第一步，构建 DOM 树：用 HTML 分析器，分析 HTML 元素，构建一棵 DOM 树；
- 第二步，构建CSSOM规则树，生成样式表：用 CSS 分析器，分析 CSS 文件和元素上的 inline 样式，生成页面的样式表；
- 第三步，构建 Render 树：将 DOM 树和样式表关联起来，构建一棵 Render 树（Attachment）。每个 DOM 节点都有 attach 方法，接受样式信息，返回一个 render 对象（又名 renderer），这些 render 对象最终会被构建成一棵 Render 树；
- 第四步，确定节点坐标：根据 Render 树结构，为每个 Render 树上的节点确定一个在显示屏上出现的精确坐标；（回流在这发生）
- 第五步，绘制页面：根据 Render 树和节点显示坐标，然后调用每个节点的 paint 方法，将它们绘制出来。（重绘在这发生）

![img](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/3534846-00ef9f3d405462ef.png)



### 如何实现水平垂直居中

#### 已知高度和宽度的元素

**方案一：**设置父元素为相对定位，给子元素设置绝对定位，`top: 0; right: 0; bottom: 0; left: 0; margin: auto;`

**方案二：**设置父元素为相对定位，给子元素设置绝对定位，`left: 50%; top: 50%; margin-left: -元素宽度的一半px; margin-top: -元素高度的一半px;`

#### 未知高度和宽度的元素

**方案一：**使用定位属性

设置父元素为相对定位，给子元素设置绝对定位，**left: 50%; top: 50%; transform: translateX(-50%) translateY(-50%);**

**方案二：**使用flex布局实现

设置父元素为flex定位，**justify-content: center; align-items: center;**

#### CSS为什么要清除浮动？如何清除浮动？

由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，最后父级盒子高度为 0 时，就会影响下面的标准流盒子。清除浮动的本质是清除浮动元素造成的影响，清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了。

清除浮动的方法有：

**1.clear:both;**

在浮动元素末尾添加一个空的标签，**这个标签必须为块级元素**。然后将其设置clear:both,这样就可以清除浮动。

**优点：**简单易懂，方便。

**缺点：**添加了无意义的冗余元素，结构化差。

```html
<div class="box">
    <div class="inner"></div>
    <div class="inner"></div>
    <div class="inner"></div>
    <div style="clear:both"></div>
</div>
```

**2.伪元素清除浮动**

给父元素添加一个before或after伪元素，然后设置伪元素的样式，这是通用的清理浮动方案。

**优点：**没有增加标签，结构更简单

**缺点：**没有照顾低版本浏览器

```css
.clearfix:after { 
 content: ""; 
 display: block; 
 height: 0; 
 clear: both; 
 visibility: hidden; 
} 
.clearfix { /* IE6、7 专有 */ 
 *zoom: 1;
}
```

**3.给父元素使用overflow:hidden;**

让父容器形成了BFC（块级格式上下文），而BFC可以包含浮动，父元素的高度计算会包括浮动元素的高度。

### 4.如何实现水平居中

#### 行内元素

1.首先看它的父元素是不是块级元素，如果是，则直接给父元素设置 **text-align: center;** 

2.如果不是，则先将其父元素设置为块级元素，再给父元素设置 **text-align: center;**

#### 块级元素

**如果宽度给定**

- 设置`margin: 0 auto;`
- 首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**left:50%**。设置子元素的 `margin-left: -元素宽度的一半px;`

**如果宽度不给**

- 定位，父元素相对定位，子元素绝对，设置子元素的**left:50%**。利用css3新增属性给子元素设置`transform: translateX(-50%);`

1.如果盒子**宽度给定**，给其（作用：使盒子自己居中）

**用flex布局**

使用flex布局，只需要给待处理的块级元素的父元素添加属性`display: flex; justify-content: center;`

### 5.如何实现盒子垂直居中

#### 单行的行内元素

只需要设置单行行内元素`line-height: 父盒子高度px;`

#### 多行的行内元素

使用给父元素设置`display:table-cell;`和`vertical-align: middle;`属即可；

```
父元素变成表格单元格，设置多行文字垂直居中
```

#### 块级元素

**方法1：定位**

首先设置父元素为相对定位，再设置子元素为绝对定位，设置子元素的**top: 50%**，即让子元素的左上角垂直居中；

1.盒子**定高度**：设置绝对子元素的 `margin-top: -元素高度的一半px;` 或者设置`transform: translateY(-50%);`

2.盒子**不定高度：**利用css3新增属性**transform: translateY(-50%);**

**flex布局**

使用flexbox布局，只需要给待处理的块状元素的父元素添加属性`display: flex; align-items: center;`

#### BFC是什么，怎么样形成BFC，BFC有什么作用？

BFC （Block Formatting Context） 是**块级格式化上下文**，它是一个独立的渲染区域.

**怎样形成一个BFC？** 

只要满足以下条件之一就会形成BFC

- 根元素

- 浮动：float元素除了none以外。
- position的值为absolute或fixed
- overflow 值不是 **visible**
- display的值为inline-block，table-cell等。

**BFC的约束规则**

- 计算BFC的高度时，浮动子元素也参与计算。
- BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然。
- 盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。
- BFC的区域不会与float box重叠。

**BFC用处**

1. 清除浮动，给父元素添加overflow:hidden。因为计算BFC的高度时，浮动元素也参与计算。
2. 用于两栏自适应布局
3. 防止垂直margin合并。

```
平方向上的margin累加,而兄弟结构垂直方向上的margin是合并的
```

>- CSS3新增的G（grid）FC、F（flex）FC
>- 如何实现两栏自适应布局
>- 如何防止垂直margin合并

#### 防止垂直margin合并

根元素形成一个BFC，在p外面包裹一层容器，并触发该容器生成一个新BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。

```html
<p>Haha</p>
<div class="wrap">
    <p>Hehe</p>
</div>
```

```css
<style>
    .wrap {
        overflow: hidden;
    }

    p {
        color: #f55;
        background: #fcc;
        width: 200px;
        line-height: 100px;
        text-align: center;
        margin: 100px;
    }
</style>
```

**同理可以防止水平margin合并**

**实现两栏自适应布局**

两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式。

**实现方式：float + overflow:hidden**

**实现原理：**侧边栏设置float：left或right，主内容栏通过overflow触发BFC，BFC不会重叠浮动元素，实现两列的一个分离。

```html
 <div class="box">
    <div class="left">leftleft</div>
    <div class="right">right/right</div>
  </div>
```

```css
<style>
    .left {
      height: 400px;
      float: left;
      margin-right: 20px;
      background-color: pink;
    }

    .right {
      overflow: hidden;
      height: 400px;
      background-color: red;
    }
</style>
```

**效果图**

![image-20210406190516412](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406190516412.png)

**注意点:如果侧边栏在右边时，注意渲染顺序。即在HTML中，先写侧边栏后写主内容**

#### CSS常见布局

单列、两列、三栏布局、等高布局。

#### 怎么用栈去实现队列

建两个栈s1、s2，在出栈的时候把栈底元素取出来，入栈的时候正常入栈。

1、入栈请求时，将数据压入s1。

2、出栈请求时，判断s2栈是否为空，不为空则将s2栈顶元素出栈；若为空，则将s1中数据依次压入s2，再取s2栈顶元素。

#### 前端语言和后端语言区别

前端开发语言主要有：HTML，CSS，Javascript，TypeScirpt，NodeJS等。
后端开发语言有：JAVA/C#/.Net/Python等。

前端开发和后端开发的职责不太一样：

- 前端开发主要负责用户的可浏览区域的展示，包括Web前端开发，移动端开发和数据可视化开发等。
- 后端开发主要负责应用程序的数据处理层，与数据库的通信以及业务实现，进行接口设计和功能实现等工作。

#### 面向对象和面向过程

面向对象，它是一种对现实世界的一个抽象。把相关的数据和方法组织为一个整体来看待，万物皆对象。

面向过程，就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现。

例如，以下象棋为例，面向过程的思想就是分析问题的步骤：1、开始游戏 ，2、黑旗先走， 3、绘制画面，4、判断输赢，5、白旗移动，6、判断输赢，8、循环步骤，9、输出结果。

面向对象的思想，下象棋可以抽象出几个对象：玩家对象、棋盘对象、规则对象。

玩家对象中有一些的方法：移动棋盘，让第二个对象（棋盘对象）改变棋子布局等。

棋盘对象中有一些方法：绘制棋盘画面、移动棋子等。

规则对象中有一些方法：判断输赢等

总的来说，面向过程是分析解决问题的步骤，面向对象是以涉及对象为整体分析。

#### 路由的history 模式和 hash 模式的区别, 在浏览器有什么影响。

hash模式的特点是url中带有一个 #， hash 值变化不会导致浏览器向服务器发出请求，而是直接触发的浏览器 `hashchange` 事件，然后通过获取 `location.hash` 得到当前的路径标识符，再进行一些路由跳转的操作。

1. `location.href`：返回完整的 URL
2. `location.hash`：返回 URL 的锚部分
3. `location.pathname`：返回 URL 路径名
4. `hashchange` 事件：当 `location.hash` 发生改变时，将触发这个事件

```
# http://hao123/base/#/page1
{
  "href": "http://hao123/base/#/page1", 
  "pathname": "/base/",
  "hash": "#/page1"
}
```

history模式，它是使用了HTML5提供的History api，他里面提供了很多方法，我们可以通过back、forward、go切换历史状态，history 模式改变 url 的方式会导致浏览器向服务器发送请求。

1. `history.go(n)`：路由跳转，比如n为 `2` 是往前移动2个页面，n为 `-2` 是向后移动2个页面，n为0是刷新页面
2. `history.back()`：路由后退，相当于 `history.go(-1)`
3. `history.forward()`：路由前进，相当于 `history.go(1)`

**两者的区别：**

1、 hash 能兼容到IE8， history 只能兼容到 IE10；

2、 hash 值变化不会导致浏览器向服务器发出请求，history 模式改变 url 的方式会导致浏览器向服务器发送请求。

3、hash比较丑陋，history比较美观。

#### 什么是回流和重绘，如何避免？

**什么是回流和重绘**

重绘：元素样式改变但不影响它在文档流的位置，这个时候浏览器会将新样式赋予元素并重新绘制，这个过程就叫重绘。

回流：元素样式改变导致页面布局和几何信息发生变化，这个时候需要重新计算节点的位置和几何信息，这个过程就叫回流。比如以下情况：

- 添加或者删除**可见**的 DOM 元素
- 元素位置发生变化
- 元素尺寸发生变化，改变边距、边框大小、宽度和高度

- 浏览器窗口尺寸改变（因为回流是根据视口的大小来计算元素的位置和大小的）

**注意：回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多。**

**如何减少/避免回流？**

```
1.CSS方面
	避免Table
	动画效果用于xx元素
	避免使用CSS表达式
2.JavaScript方面
	避免频繁操作样式
	避免频繁操作DOM
```

1、批量修改元素样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。

```js
const el = document.getElementById('test');
el.style.padding = '5px';
el.style.borderLeft = '1px';
el.style.borderRight = '2px';
```

**改进：**

```js
const el = document.getElementById('test');
el.className += ' active';
```

```css
.active{
    padding:5px;
    border-left:1px;
    border-right:2px;
}
```

2、批量修改DOM。

>- 如何批量修改DOM

3、避免触发同步布局事件

由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！**当你获取布局信息的操作的时候，会强制队列刷新**，例如访问以下属性或方法：

- offsetTop、offsetLeft、offsetWidth、offsetHeight
- scrollTop、scrollLeft、scrollWidth、scrollHeight
- clientTop、clientLeft、clientWidth、clientHeight
- getComputedStyle()
- getBoundingClientRect

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。**

4、对于复杂动画，使用绝对定位脱离文档流。

对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。

5、css3硬件加速（GPU加速）

- 使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。

- 对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。

**如何使用**

常见的触发硬件加速的css属性：

- transform
- opacity
- filters

**缺点：**

- 太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。
- GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。

#### 如何批量修改DOM

当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：

1. 首先，使元素脱离文档流
2. 其次，对其进行多次修改
3. 最后，将元素带回到文档中。

第一步和第三步可能会引起回流，但是在第二步中对DOM中能够的修改不会引发回流和重绘，因为元素不在渲染树中。就能一次性的修改DOM。

元素脱离文档流的方法：

- 隐藏元素，display:none，修改之后，再重新显示
- 使用文档片段document fragment在当前DOM之外构建一个子树，再把它拷贝回文档。

**优化例子：**

批量插入节点：

```js
function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i < data.length; i++) {
    	li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}

const ul = document.getElementById('list');
appendDataToElement(ul, data);

```

如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。

**优化：**

元素隐藏、修改DOM、重新显示

```js
function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i < data.length; i++) {
    	li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}
const ul = document.getElementById('list');
ul.style.display = 'none';
appendDataToElement(ul, data);
ul.style.display = 'block';
```

使用文档片段构建子树，拷贝回文档：

```js
const ul = document.getElementById('list');
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);
```

#### attribute和property的区别

attribute 是 **dom 元素**<u>在文档中</u>**作为** html 标签**拥有的属性**
property 是 **dom 元素**<u>在 js 中</u>**作为**对象**拥有的属性。** 

对于 html 的标准属性来说，attribute 和 property 是同步的，是会自动更新的(input的value值除外)，但是对于自定义的属性来说，他们是不同步的。

```html
  <input type='text' name="testName" class="testClass" cc='111' id='testInpt' value='123' />
  <script>
    var input = document.querySelector(".testClass");
    input.addEventListener("blur", function () {
      console.log("property 的值");
      console.log(input.value);
      console.log("attribute 的值");
      console.log(input.getAttribute("value"));
    })
  </script>
```

![image-20210202123156401](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210202123156401.png)

#### 实现两栏自适应

两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式。

##### 方法一：float + overflow:hidden

**实现原理：**侧边栏设置float：left或right，主内容栏通过overflow触发BFC，BFC不会重叠浮动元素，实现两列的一个分离。

```html
 <div class="box">
    <div class="left">leftleft</div>
    <div class="right">right/right</div>
  </div>
```

```css
<style>
    .left {
      height: 400px;
      float: left;
      margin-right: 20px;
      background-color: pink;
    }

    .right {
      overflow: hidden;
      height: 400px;
      background-color: red;
    }
</style>
```

**效果图**

![image-20210406190516412](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406190516412.png)

**注意点:如果侧边栏在右边时，注意渲染顺序。即在HTML中，先写侧边栏后写主内容**

##### 方法二：flex布局

**实现原理：**父元素display:flex，主内容栏flex : 1

```html
<div class="parent">
    <div class="left">leftleft</div>
    <div class="right">right</div>
</div>
```

```css
<style>
    .parent {
        display: flex;

    }

    .right {
        margin-left: 20px;
        height: 400px;
        flex: 1;
        background-color: red;
    }

    .left {
        height: 400px;
        background-color: pink;
    }
</style>
```

效果上同

##### 方法三：Grid布局

```html
<style>
    .parent {
        display: grid;
        grid-template-columns: auto 1fr;
        grid-template-rows: 1;
    }

    .left {
        background-color: pink;
        margin-right: 20px;
        height: 400px;
    }

    .right {
        background-color: red;
        height: 400px;
    }
</style>
```

```css
<div class="parent">
    <div class="left">leftleft</div>
    <div class="right">right</div>
</div>
```

>- 介绍一下Grid布局
>- 介绍一下Flex布局

#### 实现三栏自适应布局

三栏自适应布局就是，中间列自适应宽度，旁边两侧固定宽度。

```
flex布局 和 grid布局也可以实现
```

**实现原理：负外边距 + 相对定位**

**实现思路：**

1、三栏均设置左浮动，设置center宽度为100%，设置左右栏固定宽度。（此时left和right会跳到下一行）

2、通过设置margin-left为负值让left和right部分回到与center部分同一行。

- left  margin-left :-100%
- right margin-left : - 自身宽度px

3、设置父容器padding-left 和 padding-right ，一般设置值 > 固定栏宽度，留出间隙。

4、通过相对定位，分别改变left 和right 的左右偏移量，让其移动到两边。

**代码：**

```html
<div class="box">
    <div class="center">
        <p>123</p>
        <p>123</p>
        <p>123</p>
        <p>123</p>
        <p>123</p>
        <p>123</p>
    </div>
    <div class="left">left</div>
    <div class="right">right</div>
</div>
```

**dom结构必须是先写中间列部分，这样实现中间列可以优先加载**。

```css
<style>
    .box {
        padding-left: 220px;
        padding-right: 220px;
    }

    .center {
        float: left;
        width: 100%;
        background-color: pink;
    }

    .left {
        float: left;
        position: relative;
        left: -220px;
        width: 200px;
        margin-left: -100%;
        background-color: red;
    }

    .right {
        float: left;
        position: relative;
        right: -220px;
        width: 200px;
        margin-left: -200px;
        background-color: skyblue;
    }
</style>
```

![image-20210406210059504](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210406210059504.png)

#### 实现等高布局

等高布局是指子元素在父元素中高度相等的布局方式。

**实现思路：**设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉。

**新增CSS代码：**

```css
.center,
.left,
.right {
    padding-bottom: 10000px;
    margin-bottom: -10000px;
}
.container {
    padding-left: 220px;
    padding-right: 220px;
    overflow: hidden;//把溢出背景切掉
}
```

#### 介绍一下Grid布局

#### 介绍一下Flex布局

#### 判断数据类型的方法

**基本类型判断**

在 JavaScript 里 使用 typeof 来判断数据类型，只能区分基本类型，即 “ number ” ， “ string ” ， “ undefined ” ， “ boolean ” ， “ object ” 五种。

```js
typeof '';               // string 有效
typeof 1;                // number 有效
typeof true;             // boolean 有效
typeof undefined;        // undefined 有效
typeof null;             // object 无效
typeof [] ;              // object 无效
typeof new Function();   // function 有效
typeof new Date();       // object 无效
typeof new RegExp();     // object 无效
```

**引用类型判断**

区别对象、数组、函数可以使用Object.prototype.toString.call 方法。判断某个对象值属于哪种内置类型。

```js
console.log(Object.prototype.toString.call(123))          // [object Number]
console.log(Object.prototype.toString.call('123'))        // [object String]
console.log(Object.prototype.toString.call(undefined))    // [object Undefined]
console.log(Object.prototype.toString.call(true))         // [object Boolean]
console.log(Object.prototype.toString.call({}))           // [object Object]
console.log(Object.prototype.toString.call([]))           // [object Array]
console.log(Object.prototype.toString.call(function(){})) // [object Function]
console.log(Object.prototype.toString.call(this));        // [object Window]
```

**对象类型判断**

`instanceof` 运算符也常常用来判断对象类型。用法: 左边的运算数是一个`object`，右边运算数是对象类的名字或者构造函数; 返回`true`或`false`。

```js
[] instanceof Array; // true
[] instanceof Object; // true
[] instanceof RegExp; // false
new Date instanceof Date; // true
```

#### Object.prototype.toString的原理

在 Object.prototype.toString 方法被调用时，会执行以下操作：

1. 首先，获取this对象的[[Class]]属性的值。
2. 其次，将[[Class]]属性的值与字符串"object"进行一个拼接
3. 最后，返回这个字符串

>- 说一下[[Class]]属性

[[Class]]是一个内部属性，所有的对象都拥有该属性。在规范中，[[Class]]的值是一个字符串值，表明了该对象的类型。

#### typeof null输出什么

输出“object"，为什么？

因为不同的对象在底层都表示为二进制，在Javascript中二进制前三位都为0的话会被判断为Object类型，null的二进制表示全为0，自然前三位也是0，所以执行typeof时会返回"object"。 

>- typeof的原理

#### typeof NaN 的结果是什么？

typeof NaN; // "number"

NaN 意指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况。

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN != NaN为 true。

#### typeof的原理

`typeof`原理：不同的对象在底层都表示为二进制，在Javascript中二进制低三位存储其类型信息。

- 000: 对象
- 010: 浮点数
- 100：字符串
- 110： 布尔
- 1： 整数

#### instanceof的原理

instanceof的原理是通过原型对象去寻找，每一个对象都有一个原型指向原型对象， 这个原型对象上又有一个constructor指向构造函数，判断这个构造函数是否与Instanceof后面的名称相同，如果不相同，那继续寻找这个原型对象的原型，直到原型链的尽头。

如果找到了，就返回true ，如果搜索到原型链尽头了，还找不到就返回false。

```js
function Foo() {};

console.log(Object instanceof Object); // true
console.log(Function instanceof Function); // true
console.log(Function instanceof Object); // true

console.log(Foo instanceof Foo); // false
console.log(Foo instanceof Object); // true
console.log(Foo instanceof Function); // true

```



#### 介绍 js 有哪些内置对象？

#### 介绍一下JavaScript 原型、原型链？原型链有什么特点？

```
构造函数原型 prototype
对象原型 __ proto __
```

```
回答思路：
1.构造函数原型
2.对象原型
3.原型链
4.原型链的特点
```

**构造函数原型：**每一个构造函数的内部都有一个 prototype 属性，这个属性时一个指针，指向另一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。

**对象原型：**当我们使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，这个指针称为对象的原型。

```
一般来说我们是不应该能够获取到这个值的，但是现在浏览器中都实现了 __proto__ 属性来让我们访问这个属性，但是我们最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。
```

**原型链**

JS的原型链是指原型与原型层层相连接的过程即为原型链。当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype，然后Object.prototype.__proto _ _为null。

![image-20210407210035841](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210407210035841.png)

#### 0.1 + 0.2 等于多少

0.3000000000000004。不会精确等于0.3。

首先，十进制的0.1和0.2会被转换成二进制的，二进制浮点数表示法并不能精确的表示类似0.1这样的数值，因为浮点数在转化为二进制时，会出现无限循环

```
0.1 -> 0.0001 1001 1001 1001...(1100循环)
0.2 -> 0.0011 0011 0011 0011...(0011循环)
```

两者相加之后得到二进制为再转换为十进制，就成了0.30000000000004。所以在进行算术计算时会产生误差。

**原因：**JavaScript中所有数字包括整数和小数都只有一种类型 — Number。它的实现是使用64位固定长度来表示，也就是标准的 double 双精度浮点数。

这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

64位比特又可分为三个部分：

- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

>- 小数如何取整，或保留几位小数
>- 为什么使用二进制进行存储

#### 小数如何取整，或保留几位小数

可以使用toFixed方法，可把 Number 四舍五入为指定小数位数的数字。

```
var num = 5.56789;
var n=num.toFixed(2);
```

输出：

```
5.57
```

#### 为什么使用二进制进行存储数字

1、可以归一化处理整数和小数，节省存储空间。

2、二进制在电路设计中物理上更易实现

#### 页面性能优化

1、代码压缩 

- css代码压缩，使用clean-css对css进行压缩

- js代码压缩，使用uglifyjs-webpack-plugin对js进行压缩

2、非核心代码异步加载异步加载的方式

异步加载的三种方式——async和defer、动态脚本创建

- async属性
  - 在script上边使用async属性，会异步执行引入的JavaScript。
  - 如果是多个脚本，该方法不能保证脚本按顺序执行。

- defer属性
  - 在script上边使用defer属性，会延迟执行引入的JavaScript。
  - 若果是多个脚本，可以确保设置defer属性的脚本按顺序执行。

- 动态创建script标签
  - window.onload方法确保页面加载完毕再将script标签插入到DOM中

>- 使用async/defer后的js脚本会阻塞文档的解析吗？

3、利用浏览器缓存

浏览器缓存能够提升页面性能，并且减少服务器压力。

4、使用CDN

5、Gzip压缩

>- CDN它是如何做到加速的？/ CDN的原理

#### 使用async/defer后的js脚本会阻塞文档的解析吗？

defer是在HTML解析完之后才会执行，不会阻塞文档的解析。

而 aysnc 它是加载完成后立即执行，也就是说，设置async属性的js脚本的加载不会阻塞文档的解析，但是他的执行会阻塞文档的解析。

>- 说一下js是如何阻塞文档的解析的

#### CDN它是如何做到加速的？/CDN的原理

在我的认知里，CDN就是由遍布在各个地方的服务器组成，用户访问时，可以访问到距离最近的、状态最好的一个服务器节点，从而实现加速。

CDN的基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的环节，使内容传输的更快、更稳定。CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向到离用户最近的服务器节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。

我们从过程研究一下CDN的原理，使用CDN后，将经历这些过程

1. 当用户点击网站页面上的URL，经过本地DNS解析，本地DNS会最终将域名的解析权交给CNAME指向的CDN专用DNS服务器。

   ```
   CNAME：Canonical Name，返回另一个域名，令当前查询域名挑去该域名，多个域名->服务器的映射。
   ```

2. CDN的DNS服务器将CDN的全局负载均衡设备IP地址返回用户。

3. 用户向CDN的全局负载均衡设备发起URL访问请求。

4. CDN全局负载均衡设备根据用户IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求。

5. 区域负载均衡设备会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：用户IP地址、URL中携带的内容、服务器当前的负载情况等等，选择最近、有所需内容以及有服务能力的服务器。基于以上这些条件的综合分析之后，区域负载均衡设备会向全局负载均衡设备返回一台缓存服务器的IP地址。

6. 全局负载均衡设备把服务器的IP地址返回给用户

7. 用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。

![image-20210312140151948](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210312140151948.png)

简单来说，非CDN就是用户访问的资源统一像源站服务器请求。

CDN是根据用户IP等情况来选择合适的CDN缓存服务器来获取资源。

#### HTTP和HTTPS的区别

![image-20210408102444801](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210408102444801.png)

HTTP协议采用明文传输信息，存在信息窃听、篡改和劫持的风险。HTTPS比HTTP多了一层TLS/SSL协议，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。

HTTPS是在HTTP上建立SSL加密层，对传输数据进行加密，是HTTP协议的安全版。

>- 说一下TLS/SSL协议

#### TLS/SSL工作原理

TLS/SSL协议是安全传输层协议。它的基本工作方式是，客户端使用非对称加密与服务器进行通信，实现身份验证并协商对称加密使用的密钥， 然后对称加密算法采用协商密钥对信息以及信息摘要进行加密通信，不同的节点之间采用的对称密钥不同，从而可以保证信息只能通信双方获取。

**对称加密**

对称加密，就是相同的密钥可以用于信息的加密和解密，掌握密钥才能获取信息，能够防止信息窃听。

对称加密的特点是，信息传输1对1，密码的安全是保证信息安全的基础，服务器和 N 个客户端通信，需要维持 N 个密码记录。

**非对称加密**

非对称加密，有常见的RSA算法。算法特点是，密钥成对出现，一般称为公钥(公开)和私钥(保密)，公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。

非对称加密的特点是信息传输1对多，服务器只需要维持一个私钥就能够和多个客户端进行加密通信，但服务器发出的信息能够被所有的客户端解密。

#### HTTP状态码

常见的状态码有：

- 200 OK ：表示从客户端发来的请求在服务器端被正常处理了

- 204 No Content ：服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。

- 3XX(Redirection 重定向状态码)

  ```
  3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求
  ```

  - 301 Moved Permanently 永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。
  - 302 Found 临时性重定向。该状态码表示请求的资源已被分配了新的 URI，希望用户(本次)能使用新的 URI 访问。 和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。
  - 304 Not Modified 命中协商缓存。该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽 然被划分在 3XX 类别中，但是和重定向没有关系。

- 4XX(Client Error 客户端错误状态码)

  - 400 Bad Request 该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。
  - 401 Unauthorized 
  - 403 Forbidden 该状态码表明对请求资源的访问被服务器拒绝了。
  - 404 Not Found 该状态码表明服务器上无法找到请求的资源。

- 5XX(Server Error 服务器错误状态码)

#### HTTP的请求方式，Get和Post的区别

- 从**缓存**的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。

- 从**编码**的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。

- 从**参数**的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。

#### 如何理解 HTTP 代理？

我们知道在 HTTP 是基于`请求-响应`模型的协议，一般由客户端发请求，服务器来进行响应。

另一种情况是，代理服务器的情况。引入代理之后，作为代理的服务器相当于一个中间人的角色，对于客户端而言，表现为服务器进行响应；而对于源服务器，表现为客户端发起请求。

那代理服务器的好处：

1. **负载均衡**。例如一个网站的内容被部署在若干台服务器上，可以把这些机子看成一个集群，那么代理服务器可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的负载均衡。
2. 安全稳定。
   - 使用带服务器后，用户端将无法直接通过请求访问真正的内容服务器，而必须首先通过代理服务器。可以通过在代理服务器上将危险或者没有权限的请求内容过滤掉，从而保证了服务器的安全。
   - 利用心跳机制监控后台的服务器，一旦发现故障机就将其踢出集群。以后代理进来的客户端请求都不会被发送到该服务器上，从而保证客户端访问的稳定性。

#### HTTP1.0和HTTP1.1的区别