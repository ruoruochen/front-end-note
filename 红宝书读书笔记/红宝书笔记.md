# 第一章 什么是JavaScript

## 1.1 JavaScript 实现

完整的JavaScript实现包括以下几个部分

- 核心 ECMAScript
- 文档对象模型 DOM
- 浏览器对象模型 BOM

![image-20210506075609315](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506075609315.png)

**ECMAScript**

它描述了JavaScript语言的语法、类型、语句、关键字、保留字、全局对象等等。

**DOM**

文档对象模型（DOM，Document Object Model）是一个应用编程API，DOM 将整个页面抽象为一组分层节点。

```html
<html> 
     <head> 
    	 <title>Sample Page</title> 
     </head> 
     <body> 
    	 <p> Hello World!</p> 
     </body> 
</html>
```

这些代码通过 DOM 可以表示为一组分层节点

![image-20210506080336074](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506080336074.png)

DOM 通过创建表示文档的树，让开发者可以随心所欲地控制网页的内容和结构。使用 DOM API，可以轻松地删除、添加、替换、修改节点。

**BOM**

浏览器对象模型（BOM），用于支持访问和操作浏览器的窗口。

# 第二章 HTML中的JavaScript

### 2.1 < script >元素

**属性**

| 属性  | 描述                                                         |
| ----- | ------------------------------------------------------------ |
| async | 可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。<br>只对外部脚本文件有效。 |
| defer | 可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。<br>只对外部脚本文件有效。 |
| src   | 可选。表示包含要执行的代码的外部文件。                       |

#### 2.1.1 defer 延迟执行脚本

- 设置 defer 属性，延迟执行脚本。立即下载脚本，但把脚本延迟到文档渲染完毕后再执行。
- 多个脚本按照它们出现的顺序执行
- 在 DOMContentLoaded 事件之前执行
- 只对外部脚本文件才有效。

#### 2.1.2 async 异步执行脚本

- 设置async属性，异步执行脚本。如果脚本已经加载好，就会开始执行，脚本的加载不会阻塞文档的解析，但是脚本的执行会阻塞文档的解析。

- 不能保证多个脚本执行的次序。

- 异步脚本保证会在页面的 load 

  事件前执行。

#### 2.1.3 动态加载脚本

只要创建一个 script 元素并将其添加到DOM 即可，该元素添加到DOM之前不会发送请求。

**可能出现的问题**

1、默认情况下，以这种方式创建的< script>元素是以异步方式加载的，相当于添加了 async 属性。不是所有浏览器都支持 async 属性，如果要统一动态脚本的加载行为，可以明确将其设置为同步加载：

```js
let script = document.createElement('script'); 
script.async = false; 
```

2、以这种方式获取的资源对浏览器预加载器是不可见的。这会严重影响它们在资源获取队列中的优先级。根据应用程序的工作方式以及怎么使用，这种方式可能会严重影响性能。要想让预加载器知道这些动态请求文件的存在，可以在文档头部显式声明它们：

```js
<link rel="preload" href="gibberish.js">
```

#### 2.1.4 XHTML的变化

**HTML与XHTML的区别**

- XHTML编写代码规则比HTML严格。

- XHTML中使用JavaScript必须制定type 属性且值为text/javascript，HTML 中则可以没有这个属性。

- XHTML会把`<`解析成标签的开始。

  解决方案：

  - HTML实体形式`&lt`代替`<`

  - 使用CDATA块

    ```JS
    <script type="text/javascript">
     //<![CDATA[ 
         function compare(a, b) { 
         if (a < b) { 
         console.log("A is less than B"); 
         }else { 
         console.log("A is equal or up to B"); 
         } 
     } 
    //]]>
    </script>
    ```

    在兼容 XHTML 的浏览器中，这样能解决问题。但在不支持 CDATA 块的非 XHTML 兼容浏览器中

    则不行。为此，CDATA 标记必须使用 JavaScript 注释来抵消.

### 2.2 文档模式

文档模式：混杂模式和标准模式，使用doctype切换文档模式。

混杂模式在所有浏览器中都以省略文档开头的 doctype 声明作为开关。

### 2.3 < noscript>元素

**作用：**当浏览器不支持脚本或浏览器对脚本的支持被关闭时，将渲染`<noscript>`中的内容；否则，浏览器不会渲染`<noscript>`。

**注意事项：**`<noscript>`元素中可以包含任何可以出现在body中的HTML元素，除了`<script>`元素。

```html
<!DOCTYPE html> 
<html> 
 <head> 
     <title>Example HTML Page</title> 
     <script defer="defer" src="example1.js"></script> 
     <script defer="defer" src="example2.js"></script> 
 </head> 
 <body> 
 <noscript> 
     <p>This page requires a JavaScript-enabled browser.</p> 
 </noscript> 
 </body> 
</html>
```

这个例子是在脚本不可用时让浏览器显示一段话。如果浏览器支持脚本，则用户永远不会看到它。

## 第三章 语言基础

### 3.1 语法

1、区分大小写

2、标识符

- 第一个字符必须是一个字母、下划线（_）或美元符号（$）；
-  剩下的其他字符可以是字母、下划线、美元符号或数字。

**建议以驼峰命名法**

3、严格模式

- 对于不规范的写法、不安全的活动抛出错误。

- 开启严格模式：在脚本开头加上这一行

  "use strict"; 

  或对某个函数开启严格模式，则放在函数体开头。

  ```js
  function doSomething() { 
   "use strict"; 
   // 函数体 
  }
  ```

#### 3.1.1 严格模式下的限制

- 给未声明的变量赋值，则会导致抛出 ReferenceError。
- 八进制字面量在严格模式下是无效的

### 3.2 关键字和保留字

**关键字**

![image-20210506090223875](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506090223875.png)

**保留字**

![image-20210506090244527](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506090244527.png)

### 3.3 变量

声明变量的三种方式：var、let 、const。

#### 3.3.1 var、let 、const的区别

1、var

- 函数作用域
- 未声明直接赋值，创建全局变量。
- 可以重复声明
- var变量提升（声明提升，赋值不提升）
- 全局作用域中声明，则成为window对象的属性

2、let

- 块级作用域

- 同一个块级作用域不可重复声明（报错），但不同块级作用域下声明相同标识符不会报错。

  ```js
  //例子1
  let age; 
  var age; // SyntaxError
  
  //例子2
  let age; 
  let age; // SyntaxError
  ```

- let没有声明提升，故存在暂时性死区

  > 在 let 声明之前的执行瞬间被称为“暂时性死区”

- 全局作用域中声明，不会成为window对象的属性

3、const

- 用于创建一个只读的常量，声明时必须初始化。

#### 3.3.2 推荐声明风格

**1、不使用var**。

**2、const优先，let次之**

明确变量作用域、位置、不变的值，可以迅速发现意外赋值导致的错误。

### 3.4 数据类型

**基本数据类型**

ECMAScript 有 6 种简单数据类型：Undefined、Null、Boolean、Number、

String 和 Symbol。Symbol（符号）是ECMAScript 6 新增的

**复杂数据类型**

Object对象

#### 3.4.1 typeof 操作符

typeof可以判断七大类型：五种简单数据类型（null除外）+ function +object

 "undefined"表示值未定义；

 "boolean"表示值为布尔值；

 "string"表示值为字符串；

 "number"表示值为数值；

 "object"表示值为对象（而不是函数）或 null； 

 "function"表示值为函数；

 "symbol"表示值为符号。

**特殊：**

```js
typeof null 返回的是"object"。
```

#### 3.4.2 null和undefined的区别和联系

- undefine表示未初始化，null表示空对象指针。一般undefine用于给声明未赋值的变量，而null用来初始化将来要保存对象的变量。

- undefined由null值派生而来，故存在

  ```js
  null == undefined //true
  ```

#### 3.4.3 其他类型值转boolean

使用Boolean()转型函数

![image-20210506094141848](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506094141848.png)

**注意：**

```js
let s = " ";
console.log(Boolean(s));//true
```

要掌握，因为if 等流控制语句会自动执行其他类型值到布尔值的转换。

#### 3.4.4 Number

Number 类型使用64位固定长度来表示，也就是 双精度值表示整数和浮点数

##### 3.4.4.1八、十、十六进制

最基本的数值字面量格式是十进制整数，也可以用八进制或十六进制字面量表示。

- 八进制字面量：第一个数字必须是零（0），然后是相应的八进制数字（数值 0~7），超出范围则当做十进制。
- 十六进制字面量：前缀 0x（区分大小写），然后是十六进制数字，不区分大小写。

```js
let intNum = 55; // 整数
let octalNum1 = 070; // 八进制的 56 
let octalNum2 = 079; // 无效的八进制值，当成 79 处理
let hexNum1 = 0xA; // 十六进制 10 
let hexNum2 = 0x1f; // 十六进制 31
```

##### 3.4.4.2 浮点值

因为存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。

```js
let floatNum1 = 1.; // 小数点后面没有数字，当成整数 1 处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数 10 处理
```

##### 3.4.4.3 NaN

**特殊属性：**

- `NaN == NaN` 返回false
- 设计NaN的操作始终返回`NaN`

 isNaN()：该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。该函数视图将参数转数值。

```js
console.log(isNaN(NaN)); // true 
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值 10 
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值 1
```

**isNaN()可以用于测试对象。此时，首先会调用对象的 valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString()方法，并测试其返回值。**

##### 3.4.4.4 数值转换

有 3 个函数可以将非数值转换为数值：Number()、parseInt()和 parseFloat()。

**区别：**

- Number转型函数，可用于任意数据类型
- parseInt()和 parseFloat()主要用于字符串转数值。**推荐使用parseInt转整而不是Number**

**Number（）的转换规则**

- null ，返回0。

- undefined ，返回NaN。

- 数值，直接返回。

- 布尔，true返回1，false返回0。

- 字符串

  - 只包含数字或开头带加减号，直接转十进制。（会忽略前导0），Number("011")返回 11。

  - 有效浮点数，转浮点数（忽略前导0）
  - 有效十六进制，转十六进制对应的十进制数。
  - 空字符串“”或只包含空格的字符串“  ”，返回0。
  - 其他情况，返回NaN

- 对象。调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用toString()方法，再按照转换字符串的规则转换。

**parseInt转换规则**

忽略字符串最前面的空格，从第一个非空格字符串开始转换，如果第一个字符不是数值、加减号，立即返回NaN；如果第一个字符是，继续一次检测，直至字符串末尾或碰到非数值。

parseInt()函数也能自动识别不同的整数格式（十进制、八进制、十六进制），将其转成10进制

```js
let num1 = parseInt("1234blue"); // 1234 
let num2 = parseInt(""); // NaN 
let num3 = parseInt("0xA"); // 10，解释为十六进制整数
let num4 = parseInt(22.5); // 22 
let num5 = parseInt("70"); // 70，解释为十进制值
let num6 = parseInt("0xf"); // 15，解释为十六进制整数
```

parseInt()也接收第二个参数，用于指定底数（进制数），不穿底数就是让其自己解析，可能出现解析错误，**推荐始终传第二个参数**

```js
let num1 = parseInt("10", 2); // 2，按二进制解析
let num2 = parseInt("10", 8); // 8，按八进制解析
let num3 = parseInt("10", 10); // 10，按十进制解析
let num4 = parseInt("10", 16); // 16，按十六进制解析
```

**parseFloat转换规则**

从位置 0 开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，"22.34.5"将转换成 22.34。

**特点：**

- 忽略字符串开头的零，因此只能解析十进制值，不能指定底数。
- 如果没有小数点，或小数点后只有一个零，则返回整数。

```js
let num1 = parseFloat("1234blue"); // 1234，按整数解析
let num2 = parseFloat("0xA"); // 0 
let num3 = parseFloat("22.5"); // 22.5 
let num4 = parseFloat("22.34.5"); // 22.34 
let num5 = parseFloat("0908.5"); // 908.5 
let num6 = parseFloat("3.125e7"); // 31250000
```

#### 3.4.5 String类型

1、字符字面量

![image-20210506134735132](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506134735132.png)

![image-20210506134750469](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210506134750469.png)

这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释。计算长度时，算1。

2、字符串的特点

ECMAScript 中的字符串是不可变的，意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。

**因此，拼接字符串速度是非常慢的。**

```js
let lang = "Java"; 
lang = lang + "Script";
```

这里，变量 lang 一开始包含字符串"Java"。紧接着，lang 被重新定义为包含"Java"和"Script"的组合，也就是"JavaScript"。整个过程首先会分配一个足够容纳 10 个字符的空间，然后填充上"Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了。

3、 非字符串转换成字符串

使用**toString()方法**。该方法可见于数值、布尔、对象、字符串值，但**null和undefined没有toString方法**。

- 一般情况下，toString不接受参数，在对数值调用时，可以接受一个底数参数，即以什么底数来输出数值的字符串。

```js
let num = 10; 
console.log(num.toString()); // "10" 
console.log(num.toString(2)); // "1010" 
console.log(num.toString(8)); // "12" 
console.log(num.toString(10)); // "10" 
console.log(num.toString(16)); // "a"
```

**String转型函数**

转换规则：

1、如果有toString方法，则调用该方法并返回结果。

2、如果是null，返回"null"

3、如果是undefined，返回“undefined”



4、模板字符串

- 可以跨行定义字符串和字符串插值，通过${}包裹变量。
- 模板字符串内部不会进行转义，（如换行符或 Unicode 字符），会被保留下来。

#### 3.4.6 Symbol类型

ES6新增的，用于创建独一无二的变量。

用途：确保对象属性使用唯一标识符，不会发生属性冲突的危险。

**Symbol的使用**

1、Symbol

可以传入一个字符串参数对Symbol进行描述

```js
let sym = Symbol();
let fooSymbol = Symbol('foo');
console.log(fooSymbol); // Symbol(foo);
```

**Symbol()函数不能与 new 关键字一起作为构造函数使用。**避免创建Symbol包装对象。

如果要使用Symbol包装对象，可以借助Object函数。

```js
let myWrappedSymbol = Object(mySymbol); 
console.log(typeof myWrappedSymbol); // "object"
```

2、Symbol.for

`Symbol.for()`会被登记在全局注册表中供搜索。`Symbol.for()`不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的`key`是否已经存在，如果不存在才会新建一个值。

```js
let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
```

3、Symbol.ketFor查询全局注册表

```js
// 创建全局符号
let s = Symbol.for('foo'); 
console.log(Symbol.keyFor(s)); // foo 
// 创建普通符号
let s2 = Symbol('bar'); 
console.log(Symbol.keyFor(s2)); // undefined
```

4、Symbol作为属性

```js
let s1 = Symbol('foo'), 
 s2 = Symbol('bar'), 
 s3 = Symbol('baz'), 
 s4 = Symbol('qux'); 
//方法1
let o = { 
 [s1]: 'foo val' 
}; 
// 这样也可以：o[s1] = 'foo val'; 
console.log(o); 
// {Symbol(foo): foo val} 

Object.defineProperty(o, s2, {value: 'bar val'}); 
console.log(o); 
// {Symbol(foo): foo val, Symbol(bar): bar val} 

Object.defineProperties(o, { 
 [s3]: {value: 'baz val'}, 
 [s4]: {value: 'qux val'} 
}); 
console.log(o); 
// {Symbol(foo): foo val, Symbol(bar): bar val, 
// Symbol(baz): baz val, Symbol(qux): qux val}
```

类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnProperty-Symbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnProperty-Descriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键：

```js
let s1 = Symbol('foo'), 
 s2 = Symbol('bar'); 
let o = { 
 [s1]: 'foo val', 
 [s2]: 'bar val', 
 baz: 'baz val', 
 qux: 'qux val' 
}; 
console.log(Object.getOwnPropertySymbols(o)); 
// [Symbol(foo), Symbol(bar)] 
console.log(Object.getOwnPropertyNames(o)); 
// ["baz", "qux"] 
console.log(Object.getOwnPropertyDescriptors(o)); 
// {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}} 
console.log(Reflect.ownKeys(o)); 
// ["baz", "qux", Symbol(foo), Symbol(bar)]
```

4、常用内置符号

这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。

#### 3.4.7 Object类型

每个 Object 实例都有如下属性和方法。

-  constructor：用于创建当前对象的函数。
- hasOwnProperty(*propertyName*)：用于判断当前对象实例上是否存在给定的属性。要检查的属性名必须是字符串或Symbol。
- isPrototypeOf(*object*)：用于判断当前对象是否为另一个对象的原型。
- propertyIsEnumerable(*propertyName*)：用于判断给定的属性是否可以使用for-in 语句枚举。属性名必须是字符串。
- toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。
- toString()：返回对象的字符串表示。
- valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。

### 3.5 操作符

#### 3.5.1 一元操作符

**自增、自减**

既可以用于整数，也可以用于字符串、布尔值、浮点数、对象。

使用规则：

- 对于字符串，如果是数值形式，转数值后操作；不是字符转NaN
- 对于布尔值，false转0，true转1后操作
- 对于浮点，+1或-1。
- 对于对象，调用valueOf方法获取操作值应用上述规则，如果是NaN，调用toString应用上述规则。

**一元加、减**

一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响

```js
let num = 25; 
num = +num; 
console.log(num); // 25
```

如果将一元加应用到非数值，则会执行与使用 Number()转型函数一样的类型转换：布尔值 false和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的valueOf()和/或 toString()方法以得到可以转换的值。

```js
let s1 = "01"; 
let s2 = "1.1"; 
let s3 = "z"; 
let b = false; 
let f = 1.1; 
let o = { 
 valueOf() { 
 return -1; 
 } 
}; 
s1 = +s1; // 值变成数值 1 
s2 = +s2; // 值变成数值 1.1 
s3 = +s3; // 值变成 NaN 
b = +b; // 值变成数值 0 
f = +f; // 不变，还是 1.1 
o = +o; // 值变成数值-1
```

一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值

```js
let num = 25; 
num = -num; 
console.log(num); // -25
```

在应用到非数值时，一元减会遵循与一元加同样的规则,先对它们进行转换，然后再取负值。

#### 3.5.2 位操作

应用位操作符：64 位数值会转换为 32 位数值，然后执行位操作，最后再把结果从 32 位转换为 64 位存储起来。导致**特殊值NaN 和Infinity在位操作中都会被当成 0 处理。**

- 如果将位操作符应用到非数值，那么首先会使用 Number()函数将该值转换为数值（这个过程是自动的），然后再应用位操作。最终结果是数值。

- 位操作比`+ - * /`速度快，因为位操作是在数值底层上完成的。
- 负值以补码的二进制编码存储。

1、按位非

`~`求反。按位非的实际效果：数值取反并减1。

2、按位与

`&`符号，两个操作数，二进制一一对应，全1则1，有0则0。

3、按位或

`|`符号，两个操作数，二进制一一对应，有1则1，全0则0。

4、按位异或

`^`符号，两个操作数，二进制一一对应，相同则0，不同则1

5、左移

`<<`，数值所有位左移n位，保留符号位，右侧补0。

实际效果：数值 * 2的n次方。

6、右移

`>>`，数值所有位右移，保留符号位，左侧**以符号位值**补位。

实际效果：数值/2的n次方

7、无符号右移

`>>>`，正数无符号右移与有符号右移结果相同。负数的无符号右移以0补位。

#### 3.5.3 布尔操作符

1、逻辑非

`!`，操作数转布尔值后取反。自己看其他值转boolean的规则。

2、逻辑与

`&&`，两个操作值，全真true，有假false。如果有操作数不是布尔值，则逻辑与并不一定会返回布尔值。

- 第一个操作数为对象，返回第二个操作数。
- 第一个操作数为true，返回第二个操作数。
- 第一个操作数为null/NaN/undefined，则返回null/NaN/undefined。

`&&`是一种短路运算符，如果第一个操作符决定了结果（false或null/NaN/undefined），就不会对第二个求值。

3、逻辑或

`||`由两个管道符表示，有真则真，全假则假，如果有操作符不是布尔值，也不一定返回布尔值。

- 第一个操作数为对象，返回第一个。
- 第一个false，返回第二个。
- 两个操作数都为null/NaN/undefined，则返回null/NaN/undefined。

同样会短路，即如果第一个true，不计算第二个。

**应用：利用这个行为，可以避免给变量赋值 null 或 undefined。**

```js
let myObject = preferredObject || backupObject;
```

变量 myObject 会被赋予两个值中的一个。其中，preferredObject 变量包含首选的值，backupObject 变量包含备用的值。如果 preferredObject 不是 null，则它的值就会赋给myObject；如果 preferredObject 是 null，则 backupObject 的值就会赋给 myObject。

#### 3.5.4 乘性操作符

1、乘

`*`计算乘积。

- 有NaN，则NaN
- Infinity * 0 ，返回NaN
- Infinity * 非 0的有限数值，则根据第二个操作数的符号返回 Infinity 或-Infinity
- Infinity * Infinity ，返回Infinity
- 操作数不是数值，转数值后计算。

2、除

`/`计算除法

- 有NaN，则NaN

- Infinity / Infinity ，返回NaN

- 0/0，返回NaN

- 非0有限值 / 0，根据第一个操作数的符号返回 Infinity 或-Infinity。

- Infinity / 任何数值，根据第二个操作数的符号返回 Infinity 或-Infinity。

  Infinity / 0 ，Infinity

- 操作数不是数值，转数值后计算。

3、取模/取余数

`%`，取余。

- 有NaN，则NaN
- Infinity % Infinity，则返回 NaN
- Infinity % 任何数值，则返回 NaN
- 操作数不是数值，转数值后计算。

#### 3.5.5 指数操作符

Math.pow(底数，指数)的操作符`**`、`**=`

```js
console.log(Math.pow(3, 2); // 9 
console.log(3 ** 2); // 9

console.log(Math.pow(16, 0.5); // 4 
console.log(16** 0.5); // 4
```

```js
let squared = 3; 
squared **= 2; 
console.log(squared); // 9
```

#### 3.5.6 加减操作符

1、`+`加法

- 有NaN则NaN
- 如果是 Infinity 加 Infinity，则返回 Infinity；
- 如果是-Infinity 加-Infinity，则返回-Infinity； 
- 如果是 Infinity 加-Infinity，则返回 NaN；
- 如果是+0 加+0，则返回+0； 
- 如果是-0 加+0，则返回+0； 
- 如果是-0 加-0，则返回-0。(即有正则正)
- 如果有字符串，则字符串拼接。

2、`-`减法

- 有NaN则NaN
- 如果是 Infinity 减 Infinity，则返回 NaN。 
- 如果是-Infinity 减-Infinity，则返回 NaN。 
- 如果是 Infinity 减-Infinity，则返回 Infinity。 
- 如果是-Infinity 减 Infinity，则返回-Infinity。
- 存在字符串、布尔值、null 或 undefined，Number()转换后再计算。

#### 3.5.6 相等运算符

1、等于和不等于

`==` 和`!=`，会进行强制类型转换后在判断是否相等，转换规则：

- 两个操作数类型不相同时（布尔、字符串、数值等），转数值后比较。（null和undefined除外，这俩不能转换）
- 对象调用valueOf后比较。

比较规则：

- null == undefined
- null 和 undefined不能转换类型比较！
- 有NaN时，`==`直接false，`!=`直接true。因为**NaN 不等于 NaN。**
- 对象直接判断是否指向同一个对象。

![image-20210515095842113](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210515095842113.png)

2、全等和不全等

`===` 和`!==` 不转换的前提下比较。

**注：nul === undefined 是false**

### 3.6 语句

#### 3.6.1 标签语句与break、continue

应用：标签语句和break、continue配合，返回代码中特定位置，通常在嵌套循环中使用。

```js
let num = 0;

outermost:
for (let i = 0; i < 10; i++) {
  for (let j = 0; j < 10; j++) {
    if (i == 5 && j == 5) {
      break outermost;
    }
    num++;
  }
}
console.log(num); // 55
```

outermost 标签标识的是第一个 for 语句

## 第四章 变量、作用域与内存

### 4.2 执行上下文与作用域

执行上下文分全局上下文、函数上下文和块级上下文。

每个上下文都有一个关联的**变量对象**，这个上下文中定义的所有变量和函数都存在于这个对象上。

作用域链：其实就是我们在某个作用域中获取某个变量的值，如果在该函数中没有该变量的定义，则会到**创建这个函数的那个域**寻找，如果也没有，就会一层一层的向上寻找，直到找到全局作用域还是没有找到，就结束。这个一层层搜索的过程就是作用域链。内部上下文可以通过作用域链访问外部上下文中的一切，但外部上下文无法访问内部上下文中的任何东西。

### 4.3 垃圾回收

JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。垃圾回收的两种策略：标记清理和引用计数。

#### 4.3.1 标记清理

最常用的垃圾回收策略是标记清理。

**标记清理的实现原理：**

垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。

一般来说给变量加标记的方式有：维护“在上下文中”和“不在上下文中”两个变量列表、变量进入上下文反转一位等等。

#### 4.3.2 引用计数

比较不常用。

**引用计数的实现原理：**

对每个值都记录它被引用的次数。声明变量并给它赋一个引用值时，这个值的引用数为 1。如果同一个值又被赋给另一个变量，则引用次数加1。类似的，如果保存对这个值引用的变量被其他值覆盖，则引用次数减1。当这个值的引用次数变0时，则说明没有办法再访问这个值了，因而就可以回收其内存。垃圾回收程序下次运行的时候就会释放引用数为 0 的值的内存。

**存在的问题：**

循环引用，永远不会被释放。为避免出现循环引用，在不使用时，需要设置null解除变量引用。

#### 4.3.3 内存管理

##### 4.3.3.1 内存泄漏

1、意外声明全局变量。

```js
function setName() { 
 name = 'Jake'; 
}
```

解决：var let const 声明

2、定时器内存泄漏

3、闭包内存泄漏

4、控制台打印，因为浏览器需要一直保存着我们打印对象的信息。开发环境可以有，生产环境不要用。

##### 4.3.3.2  静态分配与对象池

静态分配是优化的一种极端形式。如果你的应用程序被垃圾回收严重地拖了后腿，可以利用它提升性能。但这种情况并不多见。大多数情况下，这都属于过早优化，因此不用考虑。

## 第五章 基本引用类型

Function、Date、RegExp、

### 5.1 Date

可以使用new 操作符调用`Date`构造函数，创建日期对象。

- 不传参数，创建对象保存当前日期和时间。`let now = new Date()`

- 传入毫秒数，创建对象为该毫秒对应日期和视觉。

  ```js
  let date = new Date(1000000000000)
  console.log(date);//2001-09-09T01:46:40.000Z
  ```

辅助方法：`Date.parse()`、`Date.UTC()`、`Date.now()`

- `Date.parse()`返回日期毫秒，接收一个**日期字符串**，若字符串格式不表示日期，返回NaN。如果直接把表示日期的字符串传给 Date 构造函数，那么 Date 会在后台调用 Date.parse()。
- `Date.UTC()`返回日期毫秒，接收年、月、日、时、分、秒、毫秒等参数，前两个必需，其他可选。Date.UTC()也会被 Date 构造函数隐式调用
- `Date.now()`返回当前方法执行时间的毫秒数。

#### 5.1.1 继承的方法

- `toLocaleString()`：返回与浏览器运行的本地环境一致的日期和时间，不包含时区信息。

- `toString()`：返回带时区信息的日期和时间。

  ```
  toLocaleString() - 2/1/2019 12:00:00 AM 
  toString() - Thu Feb 1 2019 00:00:00 GMT-0800 (Pacific Standard Time)
  ```

- `valueOf()`：被重写，返回日期的毫秒。**应用：操作符直接使用返回值**

  ```JS
  let date1 = new Date(2019, 0, 1); // 2019 年 1 月 1 日
  let date2 = new Date(2019, 1, 1); // 2019 年 2 月 1 日
  console.log(date1 < date2); // true 
  console.log(date1 > date2); // false
  ```

#### 5.1.1.2 日期格式化方法

Date 类型有几个专门用于格式化日期的方法，它们都会返回字符串：

- toDateString()显示日期中的周几、月、日、年（格式特定于实现）；
- toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；
- toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；
- toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；
- toUTCString()显示完整的 UTC 日期（格式特定于实现）。

#### 5.1.1.3 日期/时间组件方法

取得或设置日期值的特定部分

- `getTime()` 返回日期的毫秒。
- `setTime(mil)`设置日期的毫秒，改变日期。
- `getFullYear()`返回4位数的年
- `setFullYear(year)`设置日期的年
- `getMonth()`返回日期的月（11表示12月）
- `setMonth(month)`设置日期的月（>11则加年）
- `getDate()`返回日期的日
- `setDate()`设置日期的日（>当月天数，则加月）
- `getDay()`返回周几的数（0表示周日，6表示周六）
- `getHours()`返回日期的时
- `setHours(hours)`设置日期的时（>23，加日）
- `getMinites`()返回日期的分
- `setMinutes(mi)`
- `getSeconds()`
- `setSeconds()`

### 5.2 RegExp

**模板**

```js
//字面量创建
let expression = /pattern/flags;
//构造函数创建
let pattern2 = new RegExp("/pattern/", "gi");
```

**RegExp 构造函数的两个参数都是字符串**

其中pattern为正则表达式，flags为另个或多个**匹配模式**：

- g，全局模式
- i，不区分大小写
- m，多行模式

#### 5.2.1 RegExp实例的方法

**exec方法**

`exec()`，配合捕获组使用。接受一个参数，即要应用模式的字符串，若找到匹配项，则返回包含匹配信息的数组；如果没找到，返回null。

返回的数组：

- 包含两个格外的属性index 和 input，index为匹配到的起始位置，input为查找的字符串。
- 返回数组第一个元素是匹配整个模式的字符串，其余元素是捕获组匹配的。

```js
let text = "mom and dad and baby"; 
let pattern = /mom( and dad( and baby)?)?/gi; 
let matches = pattern.exec(text); 
console.log(matches.index); // 0 
console.log(matches.input); // "mom and dad and baby" 
console.log(matches[0]); // "mom and dad and baby" 
console.log(matches[1]); // " and dad and baby" 
console.log(matches[2]); // " and baby"
```

如果模式设置了全局标记，则每次调用 exec()方法会返回一个匹配的信息，即向前搜索下一个匹配项。

如果没有设置全局标记，则无论对同一个字符串调用多少次 exec()，也只会返回第一个匹配的信息。

**test方法**

`test`接收一个字符串参数，匹配true，不匹配false。

**toLocaleString()和toString()**

返回RegExp的字面量形式

### 5.3 原始值包装成对象类型

不建议将原始值包装成对象类型

#### 5.3.1 Number

`isInteger`：判断一个数值是否保存为整数。

```js
console.log(Number.isInteger(1)); // true 
console.log(Number.isInteger(1.00)); // true 
console.log(Number.isInteger(1.01)); // false
```

#### 5.3.2 String

**1、查找**

str.charAt(index)  获取指定位置的字符

indexOf() 返回某个指定的字符串值在字符串中首次出现的位置

lastIndexOf() 从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置

includes() 查找字符串中是否包含指定的子字符串。 

startsWith(x,[startindex])以x字符串开头，true/false。第二个参数为开始搜索位置。

endsWith(x,[startindex])以x字符串结尾,true/false。第二个参数表示字符串末尾位置。

**2、转换**

str.toLowerCase() 所有字符都转成小写 

str.toUpperCase() 所有的字符都转成大写 

**3.字符串连接/复制**

concat() 连接两个或更多字符串，并返回新的字符串。 

repeat() 复制字符串指定次数，并将它们连接在一起返回。 

padStart(len,str)复制字符串，小于指定长度，在左边填充字符，直至长度满足，两个参数：长度、填充字符串（默认空格,可多个字符）。

padEnd(len,str)在右边填充

```js
let stringValue = "foo"; 
console.log(stringValue.padStart(6)); // " foo" 
console.log(stringValue.padStart(9, ".")); // "......foo" 
console.log(stringValue.padEnd(6)); // "foo " 
console.log(stringValue.padEnd(9, ".")); // "foo......"

console.log(stringValue.padStart(8, "bar")); // "barbafoo" 
console.log(stringValue.padStart(2)); // "foo"
```

**4、字符串截取**

slice(start,end) 提取字符串的片断，并在新的字符串中返回被提取的部分。 

substr() 从起始索引号提取字符串中指定数目的字符。 

substring() 提取字符串中两个指定的索引号之间的字符。 

**5、字符串/数组转换**

split() 把字符串分割为字符串数组，接受两个参数，第一个为分隔符/正则，第二个为数组大小。

```js
let colorText = "red,blue,green,yellow"; 
let colors1 = colorText.split(","); // ["red", "blue", "green", "yellow"] 
let colors2 = colorText.split(",", 2); // ["red", "blue"] 
let colors3 = colorText.split(/[^,]+/); // ["", ",", ",", ",", ""]
```

**6、其他**

trim() 去除字符串前后的空白 

valueOf() 返回某个字符串对象的原始值（基本数据类型，如果没有，返回对象本身）。

**7、字符串模式匹配**

search() 查找与正则表达式相匹配的值，返回第一个匹配的位置索引，没找到返回-1。

match() 查找找到一个或多个正则表达式的匹配，将会把所有的匹配打包成一个数组返回。

**replace(字符串/RegExp对象，字符串或函数)**

```js
let text = "cat, bat, sat, fat"; 
let result = text.replace("at", "ond"); 
console.log(result); // "cond, bat, sat, fat" 
result = text.replace(/at/g, "ond"); 
console.log(result); // "cond, bond, sond, fond"
```

- 第二个参数是字符串的情况下，有几个特殊的字符序列，可以用来插入正则表达式操作的值。

  `$n` 匹配第 *n* 个捕获组的字符串。

  ```js
  let text = "cat, bat, sat, fat"; 
  result = text.replace(/(.at)/g, "word ($1)"); 
  console.log(result); // word (cat), word (bat), word (sat), word (fat)
  ```

- replace()的第二个参数可以是一个函数。在只有一个匹配项时，这个函数会收到 3 个参数：与整个模式匹配的字符串、匹配项在字符串中的开始位置，以及整个字符串。在有多个捕获组的情况下，每个匹配捕获组的字符串也会作为参数传给这个函数，但最后两个参数还是与整个模式匹配的开始位置和原始字符串。这个函数应该返回一个字符串，表示应该把匹配项替换成什么。使用函数作为第二个参数可以更细致地控制替换过程

  ```js
  function htmlEscape(text) { 
       return text.replace(/[<>"&]/g, function(match, pos, originalText) { 
           switch(match) { 
               case "<": 
               	return "&lt;"; 
           	case ">": 
           		return "&gt;"; 
          	 case "&": 
           		return "&amp;"; 
          	 case "\"": 
          		 return "&quot;"; 
           } 
       }); 
  } 
  console.log(htmlEscape("<p class=\"greeting\">Hello world!</p>")); 
  // "&lt;p class=&quot;greeting&quot;&gt;Hello world!</p>"
  ```

  

**`matchAll()`** 方法返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器。 

**8、字符串迭代和解构**

[...str]会变成元素为单个字符的数组

### 5.4 单例内置对象

另外两个单例内置对象：Global 和 Math。

#### 5.4.1 Global

在全局作用域中定义的变量和函数都会变成 Global 对象的属性 。

**eval()方法**

- 它接收一个参数，即一个要执行的 JavaScript 字符串。

  `eval("console.log('hi')"); `

  上面这行代码的功能与下一行等价

  `console.log("hi"); `

- 通过 `eval()`执行的代码属于该调用所在上下文，被执行的代码与该上下文拥有相同的作用域链，这意味着定义在包含上下文中的变量可以在 eval()中调用。

  ```js
  let msg = "hello world"; 
  eval("console.log(msg)"); // "hello world"
  ```

**Global对象属性**

我们平时接触的很多东西都是Global对象的属性

![image-20210515150805239](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210515150805239.png)

![image-20210515150820644](http://ruoruochen-img-bed.oss-cn-beijing.aliyuncs.com/img/image-20210515150820644.png)

**window对象**

浏览器将window对象实现为Global对象的代理。

#### 5.4.2 Math

1、min和max方法

2、舍入方法

- Math.ceil() 向上取整
- Math.floor()向下取整
- Math.round()四舍五入

3、random()

Math.random()返回0~1的随机数，包含0不包含1。

**应用：**从一组整数中随机选择一个数，例如实现随机出现新闻信息等。

```js
number = Math.floor(Math.random() * total_number_of_choices + first_possible_value)
//total_number_of_choices 总条数
//first_possible_value 第一个数
```

例如：1~10

```js
let num = Math.floor(Math.random()*10+1);
```

4、其他方法

Math.abs(*x*) ：返回 *x* 的绝对值

Math.e*x*p(*x*) ：返回 Math.E 的 *x* 次幂

## 第六章 集合引用类型

Object、Array。

再使用字面量创建对象、数组时不会调用其构造函数。

### 6.1 Array

ES6新增的两个静态方法：from() 和 of()

1. `from()`类数组转数组
2. `of()`一组参数转数组

类对象：可迭代的结构，如字符串。

```js
console.log(Array.from("Matt")); // ["M", "a", "t", "t"]
console.log(Array.of(1, 2, 3, 4)); // [1, 2, 3, 4]
```

#### 6.1.1 数组空位

使用一串逗号创建空位，值为undefined。

```js
const options = [,,,,,]; // 创建包含 5 个元素的数组
```

但是由于行为不一致，尽量避免使用数组空位。如果一定要使用，可以西安市使用undefined

#### 6.1.2 数组索引/长度

我们可以利用数组长度巧妙地添加/删除元素

如：arr.length = arr.length -1 即可删除最后一个元素

arr[arr.length] = xxx 即可想末尾添加元素

#### 6.1.3 检测数组

Array.isArray()

arr instanceof Array

#### 6.1.4 迭代器方法

1. keys()：数组索引迭代器
2. values()：数组元素迭代器
3. entrites()：索引/值对迭代器

**注意：迭代器 ≠ 数组**

```js
const a = ["foo", "bar", "baz", "qux"]; 
// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过 Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys()); 
const aValues = Array.from(a.values()); 
const aEntries = Array.from(a.entries()); 
console.log(aKeys); // [0, 1, 2, 3] 
console.log(aValues); // ["foo", "bar", "baz", "qux"] 
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]

for (const [idx, element] of a.entries()) { 
 alert(idx); 
 alert(element); 
}
```

#### 6.1.5 复制填充

`fill()`用于填充数组，接收三个参数：填充值、开始索引。结束索引（填充不包括结束），负值则倒着数。

```js
const zeroes = [0, 0, 0, 0, 0];

// 用 7 填充索引大于等于 1 且小于 3 的元素
zeroes.fill(7, 1, 3); 
console.log(zeroes); // [0, 7, 7, 0, 0]; 
```

`copyWithin()`浅复制数组部分内容，插入到指定索引位置，接收3个参数：插入索引（被覆盖），开始复制索引，结束复制索引（不包括结束索引）。

```js
let ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];

// 插入到索引 4 开始的位置
ints.copyWithin(4, 0, 3); 
alert(ints); // [0, 1, 2, 3, 0, 1, 2, 7, 8, 9]

ints = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];
// JavaScript 引擎在插值前会完整复制范围内的值
// 因此复制期间不存在重写的风险
ints.copyWithin(2, 0, 6); 
alert(ints); // [0, 1, 0, 1, 2, 3, 4, 5, 8, 9]
```

#### 6.1.6 Array的常用API方法

1、增删：push、pop、shift、unshift、splice

2、查找：every、some、find、findIndex、includes、indexOf、lastIndexOf、

3、拷贝（部分）/连接：slice、concat、copyWithin

4、遍历/迭代：forEach、map、filter

5、归并：reduce、reduceRight

5、其他：reverse、join、isArray、



**查找**

indexOf() 搜索元素在数组的位置，从前往后查找，返回它所在的位置，没找到返回-1。接收两个参数：查找元素、开始查找位置。

lastIndexOf() 搜索元素在数组的位置，从后往前找，返回它所在的位置，没找到返回-1。接收两个参数：查找元素、开始查找位置。

includes() 判断一个数组是否包含一个指定的值。如果是返回 true，否则false。接收两个参数：查找元素、开始查找位置。



every() 检测数值元素的每个元素是否都符合条件。存在不满足，则整个表达式返回 *false* ；所有元素都满足条件，则返回 true。

```js
array.every(function(currentValue,index,arr), thisValue)
```

some() 检测数组元素中是否有元素符合指定条件。 存在满足，true；所有都不满足，false。

```js
array.some(function(currentValue,index,arr), thisValue)
```



**断言函数**

断言函数搜索数组，断言函数接收 3 个参数：元素、索引和数组本身。断言函数返回真值，表示匹配，否则不匹配

`find()`返回第一个匹配的元素，`findIndex()`返回第一个匹配元素的索引。

```js
array.find(function(currentValue, index, arr),thisValue)
array.findIndex(function(currentValue, index, arr),thisValue)
```

```js
const people = [ 
 { 
     name: "Matt", 
     age: 27 
 }, 
 { 
     name: "Nicholas", 
     age: 29 
 } 
]; 
alert(people.find((element, index, array) => element.age < 28)); 
// {name: "Matt", age: 27} 
alert(people.findIndex((element, index, array) => element.age < 28)); 
// 0
```



**归并**

reduce() 和reduceRight()迭代数组的所有项，构建一个最终返回值。reduce()从前往后，reduceRight()从后往前。

接收两个参数：归并函数、初始值。归并函数的4个参数：上一个归并值、当前项、索引、数组本身。这个函数返回的任何值都会作为下一次调用同一个函数的第一个参数。不传初始值，第一项默认为初始值，从第二项开始迭代。

```js
let values = [1, 2, 3, 4, 5]; 
let sum = values.reduce((prev, cur, index, array) => prev + cur); 
alert(sum); // 15
```

### 6.2 定型数组

暂时用不到....看着有点乱，放着吧。

### 6.3 Map

#### 6.3.1 Map的基本API

可以使用 new Map（）创建映射，接受一个可迭代对象作为参数，需要包含键值对数组。

```js
// 使用嵌套数组初始化映射
const m1 = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
alert(m1.size); // 3
```

**基本API**

方法：set 、get 、 has 、delete 、clear

属性：size

set()方法返回映射实例，因此可以把多个操作连缀起来。

可使用扩展运算符，映射转数组。

```js
const m = new Map([ 
 ["key1", "val1"], 
 ["key2", "val2"], 
 ["key3", "val3"] 
]); 
console.log([...m]); // [[key1,val1],[key2,val2],[key3,val3]]
```

#### 6.3.2 顺序与迭代

Map 实例会维护键值对的插入顺序，因此可以根据插入顺序执行迭代操作。（而Object的迭代顺序是不一定的）

遍历：

map.entries();

map.keys();

map.values();

map.forEach((val,key)=>{})

```js
const m = new Map([
  ["key1", "val1"],
  ["key2", "val2"],
  ["key3", "val3"]
]);

for (let [key, value] of m.entries()) {
  console.log(key + ", " + value);
} 
key1, val1
key2, val2
key3, val3
```

#### 6.3.3 Object 与 Map的区别与抉择

1、内存占用

给定固定大小的内存，Map 大约可以比 Object 多存储 50%的键/值对

2、插入性能

Map插入性能较优于Object

3、查找速度

差异极小，如果代码涉及大量查找操作，那么某些情况下可能选择 Object 更好一些。

4、删除性能。

使用 delete 删除 Object 属性的性能很差，`delete obj.name;`。Map 的 delete()操作都比插入和查找更快。如果代码涉及大量删除操作，那么毫无疑问应该选择 Map。

### 6.4 WeakMap

WeakMap弱映射

#### 6.4.1 WeakMap的基本API

可以使用 new WeakMap（）创建映射，接受一个可迭代对象作为参数，需要包含键值对数组。

**基本API**

方法：set、get、has、delete

set()方法返回弱映射实例，因此可以把多个操作连缀起来

#### 6.4.2 弱键

WeakMap 中“weak”表示"弱键"，**弱键不会阻止垃圾回收**。

```js
const wm = new WeakMap(); 
wm.set({}, "val");
```

set()方法初始化了一个新对象并将它用作一个字符串的键。因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当作垃圾回收。然后，这个键/值对就从弱映射中消失了，使其成为一个空映射。

#### 6.4.3 不可迭代键

因为 WeakMap 中的键/值对任何时候都可能被销毁，所以没必要提供迭代其键/值对的能力。

#### 6.4.4 WeakMap的应用

1、私有变量

私有变量会存储在弱映射中，以对象实例为键，以私有成员的字典为值。

```js
const User = (() => { 
 const wm = new WeakMap(); 
 class User { 
 constructor(id) { 
 this.idProperty = Symbol('id');
  this.setId(id); 
 } 
 setPrivate(property, value) { 
     const privateMembers = wm.get(this) || {}; 
     privateMembers[property] = value; 
     wm.set(this, privateMembers); 
 } 
 getPrivate(property) { 
	 return wm.get(this)[property]; 
 } 
 setId(id) { 
 	this.setPrivate(this.idProperty, id); 
 } 
 getId(id) { 
 	return this.getPrivate(this.idProperty); 
 	} 
 } 
 return User; 
})(); 
const user = new User(123); 
alert(user.getId()); // 123 
user.setId(456); 
alert(user.getId()); // 456
```

2、DOM节点元数据

因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据。

```js
const wm = new WeakMap(); 
const loginButton = document.querySelector('#login'); 
// 给这个节点关联一些元数据
wm.set(loginButton, {disabled: true});

//....删除loginButton，此时弱映射，loginButton会被垃圾回收程序清除
//若使用Map 由于映射中还保存着按钮的引用，所以对应的 DOM 节点仍会逗留在内存中
```

### 6.5 Set

#### 6.5.1 基本API

Set中不包含重复的元素

```js
// 使用数组初始化集合 
const s1 = new Set(["val1", "val2", "val3"]);
```

**基本API**

方法：add、has、delete、clear

属性：size

add()返回集合的实例，所以可以将多个添加操作连缀起来。

可以使用扩展运算符将Set转数组

```js
const s = new Set(["val1", "val2", "val3"]); 
console.log([...s]); // ["val1", "val2", "val3"]
```

### 6.6 WeakSet

弱集合。

**基本API**

方法：add、has、delete  （没有clear）

没有size

**弱值**

不会阻止垃圾回收，即垃圾回收时不会考虑WeakSet中对某对象的引用。

**不可迭代**

#### 6.6.1 WeakSet的应用

给对象打标签，这样，通过查询元素在不在 disabledElements 中，就可以知道它是不是被禁用了。假如元素从 DOM 树中被删除了，垃圾回收程序则会回收它，不会管WeakSet中的引用。

```js
const disabledElements = new WeakSet(); 
const loginButton = document.querySelector('#login'); 
// 通过加入对应集合，给这个节点打上“禁用”标签
disabledElements.add(loginButton);
```

## 第七章 迭代器与生成器

### 7.1 Iterable接口/可迭代协议

实现 Iterable 接口（可迭代协议）要求同时具备两种能力：支持迭代的自我识别能力和创建实现Iterator 接口的对象的能力。要求暴露一个属性作为“默认迭代器”，这个默认迭代器属性以`Symbol.iterator`作为键，引用一个迭代器工厂函数，调用这个工厂函数返回一个新迭代器。

```js
let arr = ['a', 'b', 'c'];
//工厂函数
console.log(arr[Symbol.iterator]); // f values() { [native code] 
//迭代器
console.log(arr[Symbol.iterator]()); // ArrayIterator {}
```

#### 7.1.1 迭代器协议

迭代器是一种一次性使用的对象，迭代器 API 使用 next()方法在可迭代对象中遍历数据。

next()方法返回的迭代器对象 IteratorResult 包含两个属性：done 和 value。`done`是否遍历结束，`value`取到的值。

### 7.2 生成器/Generator函数

能在函数块中暂停和恢复执行代码

#### 7.2.1 生成器基础

特点：在函数名称前加一个`*`，表示生成器函数

```js
// 生成器函数声明
function* generatorFn() {}

// 作为类实例方法的生成器函数
class Foo { 
 * generatorFn() {} 
}
```

**箭头函数不能用来定义生成器函数**

调用生成器函数产生一个**生成器对象**，需要调用`next()`方法才会恢复执行。

**应用：**

1、生成器对象作为可迭代对象

```js
function* generatorFn() { 
 yield 1; 
 yield 2; 
 yield 3; 
} 
for (const x of generatorFn()) { 
 console.log(x); 
} 
// 1 
// 2 
// 3
```

2、使用yield实现输入和输出

yield 关键字会接收到传给 next()方法的第一个值，第一次调用 next()传入的值不会被使用，因为这一次调用是为了开始执行生成器函数。

```js
function* generatorFn(initial) { 
 console.log(initial); 
 console.log(yield); 
 console.log(yield); 
} 
let generatorObject = generatorFn('foo'); 
generatorObject.next('bar'); // foo 
generatorObject.next('baz'); // baz 
generatorObject.next('qux'); // qux
```

3、星号增强 yield 的行为，让它能够迭代一个可迭代对象

```js
function* generatorFn() { 
 yield* [1, 2, 3]; 
} 
let generatorObject = generatorFn(); 
for (const x of generatorFn()) { 
 console.log(x); 
} 
// 1 
// 2 
// 3
```

#### 7.2.2 生成器作为默认迭代器

因为生成器对象实现了 Iterable 接口，而且生成器函数和默认迭代器被调用之后都产生迭代器，所以生成器格外适合作为默认迭代器。

```js
class Foo { 
 constructor() { 
 this.values = [1, 2, 3]; 
 }
 * [Symbol.iterator]() { 
 	yield* this.values; 
 } 
} 
const f = new Foo(); 
for (const x of f) { 
 console.log(x); 
} 
// 1 
// 2 
// 3
```

## 第八章 对象、类与面向对象编程

对象：一组属性的无序集合，即没有特点顺序。

### 8.1 对象基础

#### 8.1.1 属性的类型

属性分两种：数据属性和访问器属性。

1、数据属性

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4个特性描述它们的行为。

1. [[Configurable]] ：是否可delete删除，是否可以修改特性，是否可改写成访问器属性，默认为true
2. [[Enumerable]] ：是否可以for-in，默认true
3. [[Writable]] ：是否可被修改，默认true
4. [[Value]]：包含属性实际的值。

要修改属性的默认特性，就必须使用 Object.defineProperty()方法。接收3个参数：对象、属性名称、描述对象。描述对象可以包括configurable等等。

```js
let person = {}; 
Object.defineProperty(person, "name", { 
 writable: false, 
 value: "Nicholas" 
}); 
console.log(person.name); // "Nicholas" 
person.name = "Greg"; 
console.log(person.name); // "Nicholas"
```

**注意：在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。**

与直接设置属性不同，直接设置都默认为true。

2、访问器属性

访问器属性不包含数据值。它们包含一个获取（getter）函数和一个设置（setter）函数，可选。

访

问器属性有 4 个特性描述它们的行为：

1. [[Configurable]]：是否可以 delete 删除，是否可以修改它的特性，是否可以改为数据属性。默认true。 
2.  [[Enumerable]] ：是否可以for-in，默认true
3. [[Get]]：获取函数，在读取属性时调用。默认值为 undefined。 
4. [[Set]]：设置函数，在写入属性时调用。默认值为 undefined。

访问器属性是不能直接定义的，必须使用 Object.defineProperty()。

#### 8.1.2 定义多个属性

`Object.defineProperties()`方法，这个方法可以通过多个描述符一次性定义多个属性。接收两个参数：对象、描述对象。

```js
let book = {}; 
Object.defineProperties(book, { 
 year_: { 
 	value: 2017 
 }, 
 edition: { 
	 value: 1 
 }, 
 year: { 
 	get() { 
 return this.year_; 
 }, 
 set(newValue) { 
     if (newValue > 2017) { 
         this.year_ = newValue; 
         this.edition += newValue - 2017; 
	 } 
   } 
 } 
});
```

#### 8.1.3 读取属性的特性

使用`Object.getOwnPropertyDescriptor()`方法可以取得指定属性的属性描述符，接收2个参数：对象、属性名，返回值对象，包含了configurable、get、set等属性（看具体情况是数据属性还是访问器属性）。

如果不传第二个参数，则返回一整个描述对象。

```js
let book = {}; 
Object.defineProperties(book, { 
 year_: { 
 	value: 2017 
 }, 
 edition: { 
	 value: 1 
 }, 
 year: { 
 	get() { 
 return this.year_; 
 }, 
 set(newValue) { 
     if (newValue > 2017) { 
         this.year_ = newValue; 
         this.edition += newValue - 2017; 
	 } 
   } 
 } 
});

let descriptor = Object.getOwnPropertyDescriptor(book, "year_"); 
console.log(descriptor.value); // 2017 
console.log(descriptor.configurable); // false
```

#### 8.1.4 合并对象

`Object.assign()`将源对象的属性拷贝至目标对象，接收参数：目标对象、多个源对象。**浅复制**

```js
dest = {}; 
result = Object.assign(dest, { a: 'foo' }, { b: 'bar' }); 
console.log(result); // { a: foo, b: bar }
```

#### 8.1.5 对象标识及相等判断

`Object.is()`，Object.is()的用法与全等`===`基本一致，唯有不同的两点：

1. +0与-0为false
2. NaN与NaN为true

#### 8.1.6 增强对象语法

1、可计算属性

```js
//可计算属性
let name = 'name', age = 'age', job = 'job', count = 0;
function getUnionKey(key) {
  return `${key}_${count++}`;
}

let person = {
  [getUnionKey(name)]: 'Tom',
  [getUnionKey(age)]: 18,
  [getUnionKey(job)]: 'stu'
}

console.log(person);//{ name_0: 'Tom', age_1: 18, job_2: 'stu' }
```

2、属性值简写

3、方法名简写

4、对象解构，是使用与对象匹配的结构来实现对象属性赋值。

### 8.3 继承

#### 8.3.1 原型链继承

子类的原型为父类实例，这样根据原型链，子类就可以访问到父类的属性和方法。

```js
function Father(){
    this.name = 'father';
}

Father.prototype.sayName = function(){
    console.log(this.name);
}

function Son(){
    this.age = 18;
}

//原型链继承
Son.prototype = new Father();

Son.prototype.sayAge = function(){
    console.log(this.age);
}

let son = new Son();
son.sayName();//father
son.sayAge();//18
```

优点：实现方便、简单。

缺点：

1. 原型中包含引用值，会在所有实例间共享。
2. 子类不能给父类传参

#### 8.3.2 构造函数继承

在子类构造函数中调用父类构造函数。 通过使用`call()`或`apply()`方法以当前this执行父类构造函数。

```js
function Father(){
    this.colors = ['red','pink'];
}

function Son(){
    Father.call(this);
}

let son1 = new Son();
son1.colors.push('yellow');
console.log(son1.colors);//['red','pink','yellow']

let son2 = new Son();
console.log(son2.colors);//['red','pink']
```

优先：子类可向父类传递参数

缺点：

1. 子类无法使用父类prototype上的方法
2. 父类构造函数中的方法会被反复执行，不能重用。

#### 8.3.3 组合继承

综合原型链继承和构造函数继承，将两者优点集中起来，即有自己属性，又能复用原型上的方法。

通过原型链继承继承原型上的属性和方法，通过构造函数继承继承实例属性。

```js
function Father(name){
    this.name = name;
    this.colors = ['red','pink'];
}

Father.prototype.sayName = function(){
    console.log(this.name);
}

function Son(name,age){
    Father.call(this,name);
    this.age = age;
}

Son.prototype = new Father();

Son.prototype.sayAge = function(){
    console.log(this.age);
}

let son1 = new Son('Lisa',18);
son1.colors.push('pink');
console.log(son1.colors);//['red','pink','pink']
son1.sayName();//Lisa

let son2 = new Son('Tom',50);
console.log(son2.colors);//['red','pink']
son2.sayName();//Tom
son2.sayAge();//50
```

优点：

1. 父类引用数据不会共享
2. 子类可以给父类传参
3. 子类可以共享父类原型上的方法

#### 8.3.4 原型式继承

创建一个临时构造函数，将一个对象object作为构造函数的原型，返回这个临时构造函数的实例。本质上是对object对象的浅复制。

```js
function Object(o){
    function F(){};
    F.prototype = o;
    return new F();
}

const o = {
    name:'Sherry',
    friend:['1','2'],
    age:19
}

let instance1 = Object(o);
let instance2 = Object(o);
instance1.friend.push('3');
console.log(instance2.friend);// 1 2 3
```

ECMAScript 5 通过增加 Object.create()方法将原型式继承的概念规范化了。

#### 8.3.5 寄生式继承

通过原型式继承的方法创建一个实例，然后为这个实例添加属性和方法，最后返回这个实例。

```js
function createObject(o){
    let myobj = Object.create(o);
    myobj.sagHaha = function(){
        console.log('hahaha');
    }
    return myobj;
}

const o = {
    name:'xixi',
    age:109
}
let instance = createObject(o);
instance.sayHaha();
```

#### 8.3.6 寄生式组合继承

对组合继承的优化，在组合继承中父类构造函数被调用了两次：在修改子类原型时调用、子类构造函数中调用。

优化：子类构造函数在执行时重写原型。

```js
function  inherit(Parent,Child){
    const prototype = Object.create(Parent.prototype);
	prototype.constructor = Child;
    Child.prototype = prototype;
}

function Father(){
    this.friends = [1,2,3];
}

function Son(){
    Father.call(this);
    this.age=18;
}

Son.prototype.sayAge = function(){
    console.log(this.age);
}

inherit(Father,Son)

```

### 8.4 类

#### 8.4.1 类定义

定义类：类声明和类表达式，使用`class`

```js
// 类声明
class Person {} 
// 类表达式
const Animal = class {};
```

**类定义与函数声明的区别**

- 函数声明可以提升，但是类定义不能。

```js
console.log(FunctionDeclaration); // FunctionDeclaration() {} 
function FunctionDeclaration() {} 
console.log(FunctionDeclaration); // FunctionDeclaration() {} 

console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined 
class ClassDeclaration {} 
console.log(ClassDeclaration); // class ClassDeclaration {}
```

- 函数受函数作用域限制，类受块作用域限制。

```js
{ 
 function FunctionDeclaration() {} 
 class ClassDeclaration {} 
} 

console.log(FunctionDeclaration); // FunctionDeclaration() {} 
console.log(ClassDeclaration); // ReferenceError: ClassDeclaration is not defined
```

#### 8.4.1 类构造函数

`constructor`

使用new会执行以下操作：

(1) 在内存中创建一个新对象。

(2) 这个新对象内部的[[Prototype]]指针被赋值为构造函数的 prototype 属性。

(3) 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）。

(4) 执行构造函数内部的代码（给新对象添加属性）。

(5) **如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。**

**默认情况下，类构造函数执行之后返回this对象，如果手动写了返回的对象，则会返回手动写的对象，此时这个对象instanceof 类名为false**

#### 8.4.2 实例、原型和类成员

- 在类块中定义的方法将作为原型方法，在实例间共享。

```js
class Person { 
     constructor() { 
     // 添加到 this 的所有内容都会存在于不同的实例上
    	 this.locate = () => console.log('instance'); 
     } 
     // 在类块中定义的所有内容都会定义在类的原型上
     locate() { 
     	console.log('prototype'); 
     } 
} 

let p = new Person(); 
p.locate(); // instance 
Person.prototype.locate(); // prototype
```



- 类方法等同于对象属性，因此可以使用字符串、符号或计算的值作为键：

```js
const symbolKey = Symbol('symbolKey'); 
class Person { 
     stringKey() { 
    	 console.log('invoked stringKey'); 
     } 
     [symbolKey]() { 
     	console.log('invoked symbolKey'); 
     } 
     ['computed' + 'Key']() { 
    	 console.log('invoked computedKey'); 
     } 
} 

let p = new Person(); 
p.stringKey(); // invoked stringKey 
p[symbolKey](); // invoked symbolKey 
p.computedKey(); // invoked computedKey
```

- 静态方法，使用`static`作为前缀，`this`指向类自身。

```js
class Person { 
     constructor() { 
     // 添加到 this 的所有内容都会存在于不同的实例上
    	 this.locate = () => console.log('instance', this); 
     } 
     // 定义在类的原型对象上
     locate() { 
   		 console.log('prototype', this); 
     } 
     // 定义在类本身上
     static locate() { 
     	console.log('class', this); 
     } 
} 
let p = new Person(); 
p.locate(); // instance, Person {} 
Person.prototype.locate(); // prototype, {constructor: ... } 
Person.locate(); // class, class Person {}
```

#### 8.4.3 继承

**1、`extends`实现单继承**

- 可以继承一个类、普通的构造函数或内置类型Array/String等。

- 派生类会通过原型链访问到类和原型上的方法，其实的`this`反映调用的实例或类

```js
class Vehicle { 
     identifyPrototype(id) { 
    	 console.log(id, this); 
     }
     static identifyClass(id) { 
   		 console.log(id, this); 
     } 
} 
class Bus extends Vehicle {} 
let v = new Vehicle(); 
let b = new Bus(); 

b.identifyPrototype('bus'); // bus, Bus {} (this指向调用的实例对象)
v.identifyPrototype('vehicle'); // vehicle, Vehicle {} (this指向调用的实例对象)
Bus.identifyClass('bus'); // bus, class Bus {} 
Vehicle.identifyClass('vehicle'); // vehicle, class Vehicle {}
```

**2、super**

使用注意事项：

- 只能在派生类的构造函数和静态方法中使用。
- 调用 super()会调用父类构造函数，并将返回的实例赋值给 `this`。
- 不能在调用 super()之前引用 this。
- 派生类没有构造函数，实例化时则自动调用super，并将所有参数传给父类。
- 如果在派生类中显式定义了构造函数，则要么必须在其中调用 `super()`，要么必须在其中返回一个对象。

**3、抽象基类**

定义：供其他类继承，但本身不能被实例化。

抽象基类的实现：

1、阻止对抽象类实例化。`new.target` 保存通过 `new` 关键字调用的类或函数。通过在实例化时检测 `new.target` 是不是抽象基类，如果是，则抛出错误。

2、实现类需实现抽象类中的所有方法。通过this检查是否包含某个方法，如果没有，则抛出错误。

```js
// 抽象基类
class Vehicle { 
     constructor() { 
         if (new.target === Vehicle) { 
              throw new Error('Vehicle cannot be directly instantiated'); 
         } 
         if (!this.foo) { 
        	 throw new Error('Inheriting class must define foo()'); 
         } 
         console.log('success!'); 
     } 
} 
// 派生类
class Bus extends Vehicle { 
	 foo() {} 
} 
// 派生类
class Van extends Vehicle {} 
new Bus(); // success! 
new Van(); // Error: Inheriting class must define foo()
```

**4、类混入**

>对象混入使用Object.assign()

通过类混入实现多继承。

类混入实现：定义一组“可嵌套”的函数，每个函数分别接收一个超类作为参数，而将混入类定义为这个参数的子类，并返回这个类。这些组合函数可以连缀调用，最终组合成超类表达式。

```js
class Vehicle {} 
let FooMixin = (Superclass) => class extends Superclass { 
     foo() { 
     	console.log('foo'); 
     } 
}; 
let BarMixin = (Superclass) => class extends Superclass { 
     bar() { 
     	console.log('bar'); 
     } 
}; 
let BazMixin = (Superclass) => class extends Superclass { 
     baz() { 
     	console.log('baz'); 
     } 
}; 
function mix(BaseClass, ...Mixins) { 
	 return Mixins.reduce((accumulator, current) => current(accumulator), BaseClass); 
} 

class Bus extends mix(Vehicle, FooMixin, BarMixin, BazMixin) {} 
let b = new Bus(); 
b.foo(); // foo 
b.bar(); // bar 
b.baz(); // baz
```

## 第九章 代理Proxy与反射Reflect

### 9.1 Proxy代理

代理是目标对象的抽象,代理是使用 `Proxy` 构造函数创建的，接收两个参数：目标对象和处理程序对象。（**缺一不可**）

- 在代理对象上执行的任何操作实际上都会应用到目标对象。
- 只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正常的行为。

#### 9.1.1 捕获器参数和Reflect API

所有捕获器都可以访问相应的参数，比如，`get()`捕获器会接收到目标对象、要查询的属性和代理对象三个参数，基于这些参数可以重建被捕获方法的原始行为，实现：

调用全局 Reflect 对象上（封装了原始行为）的同名方法来轻松重建。

```js
const target = { 
	 foo: 'bar' 
}; 
const handler = { 
     get() { 
     	return Reflect.get(...arguments); 
     } 
}; 

const proxy = new Proxy(target, handler); 
console.log(proxy.foo); // bar 
console.log(target.foo); // bar
```

#### 9.1.2 可撤销代理

使用 `new Proxy()` 创建的普通代理来说，会在代理对象的生命周期内一直持续存在。

如果我们预测到，未来某个时间点会撤销代理，那么我们可以使用`Proxy.revocable()`方法创建代理，在某个时间点，调用`revoke()`方法即可撤销代理。撤销代理之后再调用代理会抛出 TypeError。

```js
const target = { 
	 foo: 'bar' 
}; 
const handler = { 
     get() { 
     	return 'intercepted'; 
     } 
}; 

const { proxy, revoke } = Proxy.revocable(target, handler); 
console.log(proxy.foo); // intercepted 
console.log(target.foo); // bar 
revoke(); 
console.log(proxy.foo); // TypeError
```

### 9.2 代理捕获器和反射Reflect方法

代理可以捕获 13 种不同的基本操作，这些操作有各自不同的反射 API 方法、参数等。

1. Reflect.get()：可以替代对象属性访问操作符。
2. Reflect.set()：可以替代=赋值操作符。
3. Reflect.has()：可以替代 in 操作符或 with()。 
4. Reflect.deleteProperty()：可以替代 delete 操作符。
5. Reflect.construct()：可以替代 new 操作符。
6. Reflect.defineProperty()
7. Reflect.preventExtensions()
8. Reflect.setPrototypeOf()
9. Reflect.set()
10. Reflect.deleteProperty()

#### 9.2.1 get()

get()捕获器会在获取属性值的操作中被调用。对应的反射 API 方法为 Reflect.get()。

**1、返回值**：无限制

**2、捕获器处理程序参数**

-  target：目标对象。
- property：引用的目标对象上的字符串键属性。
-  receiver：代理对象或继承代理对象的对象。

#### 9.2.2 set()

set()捕获器会在设置属性值的操作中被调用。对应的反射 API 方法为 Reflect.set()。

**1、返回值**：返回 true 表示成功；返回 false 表示失败，严格模式下会抛出 TypeError。

**2、捕获器处理程序参数**

- target：目标对象。

- property：引用的目标对象上的字符串键属性。

- value：要赋给属性的值。

- receiver：接收最初赋值的对象。

#### 9.2.3 has()

has()捕获器会在 in 操作符中被调用。对应的反射 API 方法为 Reflect.has()

**1、返回值**：has()必须返回布尔值，表示属性是否存在。

**2、捕获器处理程序参数**：

- target：目标对象。

- property：引用的目标对象上的字符串键属性。

### 9.3 代理模式/代理Proxy的应用

跟踪属性访问

隐藏属性

属性验证

函数或构造函数参数验证

## 第十章 函数

### 10.1 函数内部对象

函数内部对象有：`arguments`、`this`、`caller`、`new.target`

**arguments**

- arguments 对象，它是一个类数组对象，包含调用函数时传入的所有参数。

- arguments 对象有一个 callee 属性，是一个指向 arguments 对象所在函数的指针，其应用：函数逻辑与函数名解耦。

>我们假设一个场景，递归函数。函数名为factorial，在递归中一直调用的都是factorial，如果在递归的过程中，factorial被外界修改了，这时候，递归中调用的是修改后的factorial，不符合我们一开始的设想了。
>
>怎么办？使用 **arguments.callee**递归调用，解决。
>
>严格模式下callee报错，如何解决？使用命名函数表达式。
>
>```js
>const factorial = (function f(num) { 
>     if (num <= 1) { 
>     	return 1; 
>     } else { 
>     	return num * f(num - 1); 
>     } 
>});
>```
>
>在外界无法访问到f

**this**

this一般指向调用它的对象。在箭头函数中，this引用的是定义箭头函数的上下文。

**caller**

`caller`：调用当前函数的函数，或者如果是在全局作用域中调用的则为 null。

```js
function outer() { 
 	inner(); 
} 
function inner() { 
    console.log(inner.caller); //显示outer函数的代码
} 
outer();
```

**new.target**

如果函数正常调用，则`new.target`为undefined；如果使用`new`关键字，则`new.target`为被调用的构造函数。

# 第十一章 承诺Promise与异步函数

### 11.1 Async 和 Await异步函数

#### 11.1.1 异步函数的应用

**1、实现sleep**

实现sleep在非阻塞时暂停。

```js
function sleep(time){
    return new Promise(resolve=>setTimeout(resolve,time));
}

async function foo(){
    const time = Date.now();
    await sleep(5000);//等待5s
    console.log(Date.now() - time);
}

foo();//5009
```

# 第12章 BOM

BOM 的核心是 window 对象，表示浏览器的实例。window 对象在浏览器中有两重身份，一个是ECMAScript 中的 Global 对象，另一个就是浏览器窗口的 JavaScript 接口。

### 12.1 window对象

#### 12.1.1 窗口关系

window.parent、window.top 和 window.self

- parent 对象则始终指向当前窗口的父窗口
- top 对象始终指向最上层（最外层）窗口，即浏览器窗口本身
- self 对象，它是终极 window 属性，始终会指向 window。

#### 12.1.2 窗口位置

screenLeft 和screenTop 属性，用于表示窗口相对于屏幕左侧和顶部的位置。

**位置移动：**使用 moveTo()和 moveBy()方法移动窗口，这两个方法都接收两个参数。

- moveTo()接收要移动到的新位置的绝对坐标 *x* 和 *y*；
- moveBy()则接收相对当前位置在两个方向上移动的像素数。

这俩方法可能会被部分或全部禁用。

#### 12.1.3 窗口大小

innerWidth、innerHeight、outerWidth 和 outerHeight

- outerWidth、outerHeight返回浏览器窗口自身大小
- innerWidth、innerHeight返回浏览器窗口中页面视口的大小（不包含浏览器边框和工具栏）。
- document.documentElement.clientWidth 和 document.documentElement.clientHeight返回页面视口的宽度和高度。

兼容IE与DOM浏览器，获取窗口中文档显示区域的宽度及高度：(IE不支持innerWidth、innerHeight、outerWidth 和 outerHeight)

```js
windows.innerWidth ? windows.innerWidth : document.body.clientWidth;
```

**改变窗口大小：**使用resizeTo()和resizeBy()方法调整窗口大小。这两个方法都接收两个参数。

- resizeTo()接收新的宽度和高度值
- resizeBy()接收宽度和高度各要缩放多少

缩放窗口的方法可能会被浏览器禁用

#### 12.1.4 视口位置

获取文档相对于视口的滚动距离

1. 水平距离：window.pageXoffset、window. scrollX（返回相等的值）
2. 垂直距离：window.pageYoffset、window.scrollY（返回相等的值）

**滚动页面：**使用 scroll()、scrollTo()和 scrollBy()方法滚动页面。

这 3 个方法都接收表示相对视口距离的 *x* 和 *y* 坐标，这两个参数在前两个方法中表示要滚动到的坐标，在最后一个方法中表示滚动的距离。

`To`绝对坐标，`By`相对距离

#### 12.1.5 系统对话框

alert、confirm、prompt

**confirm**

确认框有两个按钮：“Cancel”（取消）和“OK”（确定）。

我们可以判断 confirm()方法的返回值：true 表示单击了 OK 按钮，false 表示单击了 Cancel 按钮或对话框关闭，进行不同的操作。

**prompt()**

提示用户输入消息。

prompt()接收两个参数：要显示给用户的文本，以及文本框的默认值（可以是空字符串）。

如果用户单击了 OK 按钮，则 prompt()会返回文本框中的值。如果用户单击了 Cancel 按钮，或者对话框被关闭，则 prompt()会返回 null。

>扩展：打印对话框和查找对话框
>
>// 显示打印对话框
>
>window.print(); 
>
>// 显示查找对话框
>
>window.find(); 

### 12.2 location对象

- location 是最有用的 BOM 对象之一，提供了当前窗口中加载文档的信息，以及通常的导航功能。

- window.location 和 document.location 指向同一个对象

**属性**

- location.hash ：URL 散列值（井号后跟零或多个字符），如果没有则为空字符串。
- location.host ：服务器名及端口号
- location.hostname ：服务器名
- location.href ：当前加载页面的完整 URL
- location.pathname ：URL 中的路径和（或）文件名
- location.port ： 端口
- location.search ：URL查询字符串，以？开头

#### 12.2.1 查询字符串

逐个访问链接中的查询参数

手动实现：

```js
let getQueryStringArgs = function(){
    let qs = location.search.length>0?location.search.substring(1):"";
    let args = {};
    
    for(let item of qs.split('&').map(kv => kv.split('='))){
        //解码
        let name = decodeURIComponent(item[0]),
            value = decodeURIComponent(item[1]);
        if(name.length){
            args[name]=value;
        }
    }
    return args;
}
```

**提供了一个方法：URLSearchParams**

`URLSearchParams` 提供了一组标准 API 方法，通过它们可以检查和修改查询字符串。给`URLSearchParams` 构造函数传入一个查询字符串，就可以创建一个实例。

这个实例上暴露了 `has()`、`get()`、`set()`和 `delete()`等方法，可以对查询字符串执行相应操作。

```js
let qs = "?q=javascript&num=10"; 

let searchParams = new URLSearchParams(qs); 

alert(searchParams.toString()); // " q=javascript&num=10" 

searchParams.has("num"); // true 
searchParams.get("num"); // 10 
searchParams.set("page", "3"); 

alert(searchParams.toString()); // "q=javascript&num=10&page=3" 
searchParams.delete("q"); 
alert(searchParams.toString()); // " num=10&page=3"
```

大多数支持 URLSearchParams 的浏览器也支持将 URLSearchParams 的实例用作可迭代对象：

```js
let qs = "?q=javascript&num=10"; 

let searchParams = new URLSearchParams(qs); 

for (let param of searchParams) { 
 console.log(param); 
} 

// ["q", "javascript"] 
// ["num", "10"] 
```

#### 12.2.2 操作地址

修改 location 对象修改浏览器的地址。

1、使用 assign()方法并传入一个 URL

```js
location.assign("https://www.baidu.com/")
```

立即启动导航到新 URL 的操作，同时在浏览器历史记录中增加一条记录。

2、location.href

```js
location.href = "https://www.baidu.com/";
```

3、window.location

```js
window.location = "https://www.baidu.com/";
```

location.href 或 window.location 本质上也会以同一个 URL 值调用 assign()方法。

4、location.replace()

以上方法都会增加历史记录，如果不希望留下记录，则使用location.replace()方法。

5、reload()

重新加载当前显示的页面。调用 reload()而不传参数，页面会以最有效的方式重新加载。也就是说，如果页面自上次请求以来没有修改过，浏览器可能会从缓存中加载页面。

如果想强制从服务器重新加载，则传参数”true“。

修改 location 对象的属性也会修改当前加载的页面。其中，hash、search、hostname、pathname和 port 属性被设置为新值之后都会修改当前 URL。

除了 hash 之外，只要修改 location 的一个属性，就会导致页面重新加载新 URL。

### 12.3 navigator对象

客户端标识浏览器的标准。

**属性/方法**

- plugins ： 返回浏览器安装的插件数组。

## 第13章 客户端检测

检测浏览器，根据不同的浏览器，使用不同的解决方案。

**能力检测**

- 能力检测：测试浏览器是否支持某种特性，一般尽量使用typeof操作符操作。

  ```js
  if (object.propertyInQuestion) { 
   // 使用 object.propertyInQuestion 
  } 
  ```

- 推荐检测方案：集中监测能力，将检测结果保存在变量中，该变量布尔值用于后面条件语句，省事方便。

**浏览器分析**

- 使用`window.navigator.userAgent`返回字符串值，判断运行在什么浏览器上。

## 第14章 DOM文档对象模型

### 14.1 Node类型

所有节点类型都继承了Node类型，共享相同的属性和方法。

#### 14.1.1 节点类型检测

- 每个节点都有 nodeType 属性，表示该节点的类型。
- nodeName 始终等于元素的标签名。

```js
if (someNode.nodeType == 1){ 
 value = someNode.nodeName; // 会显示元素的标签名
}
```

#### 14.1. 2 节点属性

节点属性有7种

父元素：childNodes、fitstChild、lastChild

子元素：parentNode、previousSibling、nextSibling。

通用：ownerDocument属性是一个指向代表整个文档的文档节点的指针

**childNodes属性**

返回子节点的类数组对象。

- 可以使用中括号或items方法访问其中元素。

```js
let firstChild = someNode.childNodes[0]; 
let secondChild = someNode.childNodes.item(1); 
```

- 还提供了一个方法`hasChildNodes()`，这个方法如果返回 true 则说明节点有一个或多个子节点。

**firstChild、lastChild属性**

分别返回childNodes中的第一个节点和最后一个节点。

**parentNode属性**

返回当前元素的父元素。

**previousSibling、nextSibling属性**

分别返回当前元素的前一个兄弟元素、下一个兄弟元素，若不存在返回null

![image-20210610111512912](C:%5CUsers%5CAsus%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210610111512912.png)



#### 14.1.3 节点方法

节点方法有：appendChild、insertBefore、replaceChild、removeChild、cloneNode、normalize

**appendChild()方法**

作用：向childNodes末尾添加节点

参数：接受一个参数，要添加的节点

返回值：返回新添加的节点

特殊：如果把文档中已存在的节点作为参数传给appendChild，则该节点会从旧位置移动到末尾，而不是在末尾直接添加。**一个节点不会在文档中出现在两个地方**

**insertBefore()方法**

作用：将节点添加到childNodes的特定位置，插入在参照节点之前。

参数：2参，插入节点、参照节点

返回值：插入节点

特殊：参照节点为null，等同于appendChild插入末尾。

**replaceChild()方法**

作用：用于替换节点

参数：2参，插入节点、替换节点

返回值：被替换节点

**removeChild()方法**

作用：移除节点

参数：1参，移除的节点

返回值：被移除的节点

**cloneNode()方法**

作用：克隆节点

参数：1参，布尔值（表示是否深复制）。true深复制，即复制节点及其子DOM树；false浅复制，只复制该节点。

返回值：返回调用该方法节点的一样的节点。

**normalize()方法**

作用：处理文本节点，删除空文本节点，合并相邻文本节点

参数：无

### 14.2 Document类型

文档对象 document 是HTMLDocument 的实例（HTMLDocument继承Document）

获取文档中的`<html>`元素的两种方法

```js
document.documentElement；
document.childNodes[0]
```

获取`<body>`元素

```js
document.body
```

获取doctype

```js
document.doctype
```

#### 14.3 Text类型

Text 节点中包含的文本可以通过 nodeValue 属性访问。

Text节点的方法有：

- appendData(*text*)，向节点末尾添加文本 *text*； 

- deleteData(*offset, count*)，从位置 *offset* 开始删除 *count* 个字符；

- insertData(*offset, text*)，在位置 *offset* 插入 *text*； 

- replaceData(*offset, count, text*)，用 *text* 替换从位置 *offset* 到 *offset* *+* *count* 的

文本；

- splitText(*offset*)，在位置 *offset* 将当前文本节点拆分为两个文本节点；

- substringData(*offset, count*)，提取从位置 *offset* 到 *offset* *+* *count* 的文本。



document.createTextNode()可以用来创建新文本节点，它接收一个参数，即要插入节点的文本。